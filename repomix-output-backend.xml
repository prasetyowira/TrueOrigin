This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  backend/
    src/
      api.rs
      auth.rs
      error.rs
      global_state.rs
      icp.rs
      lib.rs
      models.rs
      rate_limiter.rs
      rewards.rs
      utils.rs
    backend.did
    Cargo.toml
.gitignore
.nvmrc
.repomixignore
Cargo.toml
dfx.json
package.json
repomix.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

src/frontend
src/declarations/
*.yaml
*.md
.dfx/
.idea/
node_modules/
target/
*output.*
</file>

<file path="repomix.config.json">
{
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/backend/src/rate_limiter.rs">
use std::borrow::Cow;
use std::collections::HashMap;
use std::cell::RefCell;

use candid::{CandidType, Deserialize, Principal, encode_one, decode_one};
use ic_cdk::api;
use ic_stable_structures::{DefaultMemoryImpl, Storable, StableBTreeMap, memory_manager::{MemoryId, MemoryManager, VirtualMemory}};

use crate::api::RateLimitInfo;
use crate::error::ApiError;
// Import the shared memory manager
use crate::global_state::MEMORY_MANAGER;

// Default values for rate limiting
const MAX_ATTEMPTS_PER_WINDOW: u32 = 5;
const WINDOW_DURATION_SECONDS: u64 = 60 * 5; // 5 minutes

// Define a unique MemoryId for this structure
const RATE_LIMIT_MEM_ID: MemoryId = MemoryId::new(6);

// Type definitions for rate limiting
#[derive(CandidType, Deserialize, Clone, Debug)]
pub struct RateLimitEntry {
    pub principal_id: Principal,
    pub product_id: Principal, 
    pub attempts: u32,
    pub window_start: u64,
    pub last_attempt: u64,
}

impl Storable for RateLimitEntry {
    fn to_bytes(&self) -> Cow<[u8]> {
        Cow::Owned(encode_one(self).expect("Failed to encode"))
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        decode_one(&bytes).expect("Failed to decode")
    }

    const BOUND: ic_stable_structures::storable::Bound = ic_stable_structures::storable::Bound::Unbounded;
}

// Key for rate limit entries: combination of user ID and product ID
#[derive(CandidType, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RateLimitKey {
    pub user_id: Principal,
    pub product_id: Principal,
}

impl Storable for RateLimitKey {
    fn to_bytes(&self) -> Cow<[u8]> {
        Cow::Owned(encode_one(self).expect("Failed to encode"))
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        decode_one(&bytes).expect("Failed to decode")
    }

    const BOUND: ic_stable_structures::storable::Bound = ic_stable_structures::storable::Bound::Unbounded;
}

// Use the standard Memory type alias if it's defined globally, or define it here
type Memory = VirtualMemory<DefaultMemoryImpl>;

thread_local! {
    // Initialize RATE_LIMITS using the shared MEMORY_MANAGER and the specific MemoryId
    static RATE_LIMITS: RefCell<StableBTreeMap<RateLimitKey, RateLimitEntry, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(RATE_LIMIT_MEM_ID))
        )
    );
}

// Helper function to create a rate limit key
fn create_rate_limit_key(user_id: Principal, product_id: Principal) -> RateLimitKey {
    RateLimitKey {
        user_id,
        product_id,
    }
}

// Check if a user is rate limited for verifying a specific product
pub fn check_rate_limit(user_id: Principal, product_id: Principal) -> Result<RateLimitInfo, ApiError> {
    let key = create_rate_limit_key(user_id, product_id);
    let current_time = api::time();

    RATE_LIMITS.with(|rate_limits| {
        let mut rate_limits_mut = rate_limits.borrow_mut();
        
        // Get or create rate limit entry
        let entry = match rate_limits_mut.get(&key) {
            Some(mut entry) => {
                // Check if window has expired and reset if needed
                if current_time > entry.window_start + WINDOW_DURATION_SECONDS {
                    // Reset the window
                    entry.window_start = current_time;
                    entry.attempts = 0;
                }
                entry
            },
            None => {
                // Create new entry
                RateLimitEntry {
                    principal_id: user_id,
                    product_id,
                    attempts: 0,
                    window_start: current_time,
                    last_attempt: 0,
                }
            }
        };

        let remaining_attempts = if entry.attempts >= MAX_ATTEMPTS_PER_WINDOW {
            0
        } else {
            MAX_ATTEMPTS_PER_WINDOW - entry.attempts
        };

        let reset_time = entry.window_start + WINDOW_DURATION_SECONDS;

        // Return info without updating the rate limit
        Ok(RateLimitInfo {
            remaining_attempts,
            reset_time,
            current_window_start: entry.window_start,
        })
    })
}

// Record an attempt and check if rate limited
pub fn record_verification_attempt(user_id: Principal, product_id: Principal) -> Result<RateLimitInfo, ApiError> {
    let key = create_rate_limit_key(user_id, product_id);
    let current_time = api::time();

    RATE_LIMITS.with(|rate_limits| {
        let mut rate_limits_mut = rate_limits.borrow_mut();
        
        // Get or create rate limit entry
        let mut entry = match rate_limits_mut.get(&key) {
            Some(mut entry) => {
                // Check if window has expired and reset if needed
                if current_time > entry.window_start + WINDOW_DURATION_SECONDS {
                    // Reset the window
                    entry.window_start = current_time;
                    entry.attempts = 0;
                }
                entry
            },
            None => {
                // Create new entry
                RateLimitEntry {
                    principal_id: user_id,
                    product_id,
                    attempts: 0,
                    window_start: current_time,
                    last_attempt: 0,
                }
            }
        };

        // Check if rate limited
        if entry.attempts >= MAX_ATTEMPTS_PER_WINDOW {
            return Err(ApiError::invalid_input(
                &format!("Rate limit exceeded. Try again after {}", entry.window_start + WINDOW_DURATION_SECONDS)
            ));
        }

        // Increment attempts and update last attempt time
        entry.attempts += 1;
        entry.last_attempt = current_time;

        // Update entry
        rate_limits_mut.insert(key, entry.clone());

        let remaining_attempts = if entry.attempts >= MAX_ATTEMPTS_PER_WINDOW {
            0
        } else {
            MAX_ATTEMPTS_PER_WINDOW - entry.attempts
        };

        let reset_time = entry.window_start + WINDOW_DURATION_SECONDS;

        Ok(RateLimitInfo {
            remaining_attempts,
            reset_time,
            current_window_start: entry.window_start,
        })
    })
}

// Record a successful verification attempt
pub fn record_successful_verification(user_id: Principal, product_id: Principal) {
    let key = create_rate_limit_key(user_id, product_id);
    let current_time = api::time();

    RATE_LIMITS.with(|rate_limits| {
        let mut rate_limits_mut = rate_limits.borrow_mut();
        
        // Get or create rate limit entry
        if let Some(mut entry) = rate_limits_mut.get(&key) {
            // Update last attempt time for successful verification
            entry.last_attempt = current_time;
            
            // Update entry
            rate_limits_mut.insert(key, entry);
        }
    });
}

// Reset rate limit for a user and product
pub fn reset_rate_limit(user_id: Principal, product_id: Principal) {
    let key = create_rate_limit_key(user_id, product_id);
    RATE_LIMITS.with(|rate_limits| {
        let mut rate_limits_mut = rate_limits.borrow_mut();
        rate_limits_mut.remove(&key);
    });
}
</file>

<file path="src/backend/src/rewards.rs">
use std::borrow::Cow;
use std::cell::RefCell;

use candid::{decode_one, encode_one, CandidType, Deserialize, Principal};
use ic_cdk::api;
use ic_stable_structures::{memory_manager::{MemoryId, VirtualMemory}, DefaultMemoryImpl, StableBTreeMap, Storable};

use crate::api::VerificationRewards;
// Import the shared memory manager
use crate::global_state::MEMORY_MANAGER;
use crate::models::{Metadata, ProductVerificationStatus};

// Points awarded for different verification types
const FIRST_VERIFICATION_POINTS: u32 = 100;
const MULTIPLE_VERIFICATION_POINTS: u32 = 10;
const SPECIAL_PROMOTION_POINTS: u32 = 50;

// Expiration time for rewards (in seconds)
const REWARDS_EXPIRATION_TIME: u64 = 86400 * 30; // 30 days

// Define unique Memory IDs for the structures in this module
const USER_REWARDS_MEM_ID: MemoryId = MemoryId::new(7);
const USER_VERIFIED_PRODUCTS_MEM_ID: MemoryId = MemoryId::new(8);
const PROMOTIONS_MEM_ID: MemoryId = MemoryId::new(9);

// Type definitions for rewards
#[derive(CandidType, Deserialize, Clone, Debug)]
pub struct UserRewards {
    pub user_id: Principal,
    pub total_points: u32,
    pub verification_count: u32,
    pub first_verifications: u32,
    pub last_reward_time: u64,
    pub metadata: Vec<Metadata>,
}

impl Storable for UserRewards {
    fn to_bytes(&self) -> Cow<[u8]> {
        Cow::Owned(encode_one(self).expect("Failed to encode"))
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        decode_one(&bytes).expect("Failed to decode")
    }

    const BOUND: ic_stable_structures::storable::Bound = ic_stable_structures::storable::Bound::Unbounded;
}

// Record of products verified by a user to prevent duplicate first verification rewards
#[derive(CandidType, Deserialize, Clone, Debug)]
pub struct UserVerifiedProducts {
    pub user_id: Principal,
    pub verified_products: Vec<Principal>,
}

impl Storable for UserVerifiedProducts {
    fn to_bytes(&self) -> Cow<[u8]> {
        Cow::Owned(encode_one(self).expect("Failed to encode"))
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        decode_one(&bytes).expect("Failed to decode")
    }

    const BOUND: ic_stable_structures::storable::Bound = ic_stable_structures::storable::Bound::Unbounded;
}

// Use the standard Memory type alias
type Memory = VirtualMemory<DefaultMemoryImpl>;

thread_local! {
    // Initialize structures using the shared MEMORY_MANAGER and unique MemoryIds
    static USER_REWARDS: RefCell<StableBTreeMap<Principal, UserRewards, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(USER_REWARDS_MEM_ID))
        )
    );
    
    static USER_VERIFIED_PRODUCTS: RefCell<StableBTreeMap<Principal, UserVerifiedProducts, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(USER_VERIFIED_PRODUCTS_MEM_ID))
        )
    );

    static PROMOTIONS: RefCell<StableBTreeMap<Principal, Metadata, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(PROMOTIONS_MEM_ID))
        )
    );
}

// Check if this is the first time a user has verified this product
pub fn is_first_verification_for_user(user_id: Principal, product_id: Principal) -> bool {
    USER_VERIFIED_PRODUCTS.with(|verified_products| {
        let verified_products_ref = verified_products.borrow();
        
        match verified_products_ref.get(&user_id) {
            Some(user_verified) => !user_verified.verified_products.contains(&product_id),
            None => true,
        }
    })
}

// Record that a user has verified a product
pub fn record_product_verification(user_id: Principal, product_id: Principal) {
    USER_VERIFIED_PRODUCTS.with(|verified_products| {
        let mut verified_products_mut = verified_products.borrow_mut();
        
        match verified_products_mut.get(&user_id) {
            Some(mut user_verified) => {
                // Only add if not already verified
                if !user_verified.verified_products.contains(&product_id) {
                    let mut updated = user_verified.clone();
                    updated.verified_products.push(product_id);
                    verified_products_mut.insert(user_id, updated);
                }
            },
            None => {
                // Create new record
                let new_verified = UserVerifiedProducts {
                    user_id,
                    verified_products: vec![product_id],
                };
                verified_products_mut.insert(user_id, new_verified);
            }
        }
    });
}

// Calculate rewards for a verification
pub fn calculate_verification_rewards(
    user_id: Principal, 
    product_id: Principal, 
    verification_status: &ProductVerificationStatus
) -> VerificationRewards {
    let is_first_verification = is_first_verification_for_user(user_id, product_id);
    api::time();
    
    // Calculate points based on verification type
    let base_points = match verification_status {
        ProductVerificationStatus::FirstVerification => FIRST_VERIFICATION_POINTS,
        ProductVerificationStatus::MultipleVerification => MULTIPLE_VERIFICATION_POINTS,
        ProductVerificationStatus::Invalid => 0,
    };
    
    // Check for special promotions
    let special_reward = get_special_promotion(product_id);
    let promotion_points = if special_reward.is_some() { SPECIAL_PROMOTION_POINTS } else { 0 };
    
    // Record the verification if valid
    if *verification_status != ProductVerificationStatus::Invalid {
        record_product_verification(user_id, product_id);
    }
    
    // Update user rewards
    let total_points = base_points + promotion_points;
    
    if total_points > 0 {
        update_user_rewards(user_id, total_points, is_first_verification);
    }
    
    VerificationRewards {
        points: total_points,
        is_first_verification,
        special_reward: special_reward.as_ref().map(|m| m.value.clone()),
        reward_description: special_reward.as_ref().map(|m| format!("Special reward: {}", m.value)),
    }
}

// Update user rewards
fn update_user_rewards(user_id: Principal, points: u32, is_first_verification: bool) {
    USER_REWARDS.with(|rewards| {
        let mut rewards_mut = rewards.borrow_mut();
        
        match rewards_mut.get(&user_id) {
            Some(user_rewards) => {
                let mut updated = user_rewards.clone();
                updated.total_points += points;
                updated.verification_count += 1;
                if is_first_verification {
                    updated.first_verifications += 1;
                }
                updated.last_reward_time = api::time();
                
                rewards_mut.insert(user_id, updated);
            },
            None => {
                // Create new rewards record
                let new_rewards = UserRewards {
                    user_id,
                    total_points: points,
                    verification_count: 1,
                    first_verifications: if is_first_verification { 1 } else { 0 },
                    last_reward_time: api::time(),
                    metadata: Vec::new(),
                };
                
                rewards_mut.insert(user_id, new_rewards);
            }
        }
    });
}

// Get special promotion for a product if available
fn get_special_promotion(product_id: Principal) -> Option<Metadata> {
    PROMOTIONS.with(|promotions| {
        promotions.borrow().get(&product_id)
    })
}

// Add a special promotion for a product
pub fn add_special_promotion(product_id: Principal, promotion_name: &str, promotion_value: &str) {
    let metadata = Metadata {
        key: promotion_name.to_string(),
        value: promotion_value.to_string(),
    };
    
    PROMOTIONS.with(|promotions| {
        promotions.borrow_mut().insert(product_id, metadata);
    });
}

// Remove a special promotion
pub fn remove_special_promotion(product_id: Principal) {
    PROMOTIONS.with(|promotions| {
        promotions.borrow_mut().remove(&product_id);
    });
}

// Get user rewards
pub fn get_user_rewards(user_id: Principal) -> Option<UserRewards> {
    USER_REWARDS.with(|rewards| {
        rewards.borrow().get(&user_id)
    })
}
</file>

<file path=".nvmrc">
16.20.0
</file>

<file path="Cargo.toml">
[workspace]
members = [
    "src/backend"
]
resolver = "2"
</file>

<file path="dfx.json">
{
  "canisters": {
    "TrustOrigin_backend": {
      "candid": "src/backend/backend.did",
      "package": "TrustOrigin_backend",
      "type": "rust"
    },
    "TrustOrigin_frontend": {
      "dependencies": [
          "TrustOrigin_backend",
          "internet_identity"
      ],
      "source": [
          "src/frontend/dist"
      ],
      "type": "assets",
      "workspace": "trustorigin"
    },
    "internet_identity": {
      "candid": "https://github.com/dfinity/internet-identity/releases/latest/download/internet_identity.did",
      "frontend": {},
      "remote": {
          "id": {
              "ic": "rdmx6-jaaaa-aaaaa-aaadq-cai"
          }
      },
      "type": "custom",
      "wasm": "https://github.com/dfinity/internet-identity/releases/latest/download/internet_identity_dev.wasm.gz"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
</file>

<file path="package.json">
{
    "engines": {
        "node": ">=16.0.0",
        "npm": ">=7.0.0",
        "pnpm": ">=7.0.0",
        "husky": "9.1.4"
    },
    "name": "trustorigin",
    "scripts": {
        "setup-declarations": "dfx generate TrustOrigin_backend",
        "build": "npm run build --workspaces --if-present",
        "prebuild": "npm run prebuild --workspaces --if-present",
        "pretest": "npm run prebuild --workspaces --if-present",
        "start": "npm start --workspaces --if-present",
        "test": "npm test --workspaces --if-present",
        "prepare": "husky"
    },
    "type": "module",
    "workspaces": [
        "src/frontend"
    ],
    "dependencies": {
        "@dfinity/agent": "^2.0.0"
    },
    "devDependencies": {
        "husky": "^9.1.4"
    },
    "packageManager": "pnpm@9.7.1+sha512.faf344af2d6ca65c4c5c8c2224ea77a81a5e8859cbc4e06b1511ddce2f0151512431dd19e6aff31f2c6a8f5f2aced9bd2273e1fed7dd4de1868984059d2c4247"
}
</file>

<file path="src/backend/src/error.rs">
use candid::{CandidType, Deserialize};
use serde::Serialize;

use crate::models::Metadata;

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub struct ErrorDetails {
    pub message: String,
    pub details: Vec<Metadata> // Optional details like field errors
}

impl Default for ErrorDetails {
    fn default() -> Self {
        ErrorDetails {
            message: String::new(),
            details: Vec::new()
        }
    }
}

// Define specific error categories
#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub enum ApiError {
    NotFound { details: ErrorDetails },
    Unauthorized { details: ErrorDetails },
    InvalidInput { details: ErrorDetails },
    InternalError { details: ErrorDetails },
    // Add other specific errors as needed
    AlreadyExists { details: ErrorDetails },
    MalformedData { details: ErrorDetails },
    ExternalApiError { details: ErrorDetails },
}

// Helper functions to create errors (optional, but can be convenient)
impl ApiError {
    pub fn not_found(message: &str) -> Self {
        ApiError::NotFound { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

    pub fn unauthorized(message: &str) -> Self {
        ApiError::Unauthorized { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

    pub fn invalid_input(message: &str) -> Self {
        ApiError::InvalidInput { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

    pub fn internal_error(message: &str) -> Self {
        ApiError::InternalError { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

     pub fn already_exists(message: &str) -> Self {
        ApiError::AlreadyExists { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

    pub fn malformed_data(message: &str) -> Self {
        ApiError::MalformedData { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }

    pub fn external_api_error(message: &str) -> Self {
        ApiError::ExternalApiError { details: ErrorDetails { message: message.to_string(), ..Default::default() } }
    }
}
</file>

<file path="src/backend/src/models.rs">
use std::{borrow::Cow, fmt};

use ic_cdk::api;
use candid::{CandidType, Principal, Deserialize, encode_one, decode_one};
use ic_stable_structures::{storable::Bound, Storable};
use serde::Serialize;

use crate::{
    error::{
        ApiError,
    },
    utils::generate_unique_principal
};

macro_rules! impl_storable_for_candid_type {
    ($type:ty) => {
        impl Storable for $type {
            fn to_bytes(&self) -> Cow<[u8]> {
                Cow::Owned(encode_one(self).expect("Failed to encode"))
            }

            fn from_bytes(bytes: Cow<[u8]>) -> Self {
                decode_one(&bytes).expect("Failed to decode")
            }

            const BOUND: Bound = Bound::Unbounded;
        }
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct Metadata {
    pub key: String,
    pub value: String,
}
impl_storable_for_candid_type!(Metadata);

impl fmt::Debug for Metadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Meta [{}: {}]", self.key, self.value)
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct Organization {
    pub id: Principal,
    pub name: String,
    pub description: String,
    pub private_key: String,
    pub metadata: Vec<Metadata>,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(Organization);

impl Default for Organization {
    fn default() -> Self {
        Organization {
            id: Principal::anonymous(), // Default value for Principal
            name: String::new(),
            description: String::new(),
            private_key: String::new(),
            metadata: Vec::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            updated_at: api::time(),
            updated_by: api::caller(), // Default value for Principal
        }
    }
}

impl fmt::Debug for Organization {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Organization")
        .field("id", &self.id)
        .field("name", &self.name)
        .field("description", &self.description)
        .field("private_key", &self.private_key)
        .field("metadata", &self.metadata)
        .field("created_at", &self.created_at)
        .field("created_by", &self.created_by)
        .field("updated_at", &self.updated_at)
        .field("updated_by", &self.updated_by)
        .finish()
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct OrganizationPublic {
    pub id: Principal,
    pub name: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(OrganizationPublic);

impl OrganizationPublic {
    pub fn from(org: Organization) -> OrganizationPublic {
        OrganizationPublic {
            id: org.id,
            name: org.name,
            description: org.description,
            metadata: org.metadata,
            created_at: org.created_at,
            created_by: org.created_by,
            updated_at: org.updated_at,
            updated_by: org.updated_by,
        }
    }
}

#[derive(CandidType, Deserialize, Clone)]
pub enum OrganizationResult {
    #[serde(rename = "organization")]
    Organization(OrganizationPublic),
    #[serde(rename = "error")]
    Error(ApiError)
}

#[derive(CandidType, Deserialize)]
pub struct OrganizationInput {
    pub name: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Deserialize)]
pub enum PrivateKeyResult {
    #[serde(rename = "key")]
    Key(String),
    #[serde(rename = "error")]
    Error(ApiError),
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct Product {
    pub id: Principal,
    pub name: String,
    pub org_id: Principal,
    pub category: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
    pub public_key: String,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(Product);

impl Default for Product {
    fn default() -> Self {
        Product {
            id: Principal::anonymous(),
            name: String::new(),
            org_id: Principal::anonymous(),
            description: String::new(),
            category: String::new(),
            metadata: Vec::new(),
            public_key: String::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            updated_at: api::time(),
            updated_by: api::caller(), // Default value for Principal
        }
    }
}

impl fmt::Debug for Product {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Product")
        .field("id", &self.id)
        .field("name", &self.name)
        .field("org_id", &self.org_id)
        .field("category", &self.category)
        .field("metadata", &self.metadata)
        .field("public_key", &self.public_key)
        .field("created_at", &self.created_at)
        .field("updated_at", &self.created_at)
        .finish()
    }
}

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub enum ProductResult {
    #[serde(rename = "product")]
    Product(Product),
    #[serde(rename = "none")]
    None,
    #[serde(rename = "error")]
    Error(ApiError)
}

#[derive(CandidType, Deserialize)]
pub struct ProductInput {
    pub name: String,
    pub org_id: Principal,
    pub category: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct ProductSerialNumber {
    pub product_id: Principal,
    pub serial_no: Principal,
    pub user_serial_no: String,
    pub print_version: u8,
    pub metadata: Vec<Metadata>,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(ProductSerialNumber);

impl Default for ProductSerialNumber {
    fn default() -> Self {
        ProductSerialNumber { 
            product_id: Principal::anonymous(),
            serial_no: generate_unique_principal(Principal::anonymous()),
            user_serial_no: String::new(),
            print_version: 0,
            metadata: Vec::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            updated_at: api::time(),
            updated_by: api::caller(), // Default value for Principal
        }
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct ProductVerification {
    pub id: Principal,
    pub product_id: Principal,
    pub serial_no: Principal,
    pub print_version: u8,
    pub metadata: Vec<Metadata>,
    pub created_at: u64,
    pub created_by: Principal,
    pub status: ProductVerificationStatus,
}
impl_storable_for_candid_type!(ProductVerification);

impl Default for ProductVerification {
    fn default() -> Self {
        ProductVerification {
            id: generate_unique_principal(Principal::anonymous()),
            product_id: Principal::anonymous(),
            serial_no: Principal::anonymous(),
            print_version: 0,
            metadata: Vec::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            status: ProductVerificationStatus::FirstVerification,
        }
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum UserRole {
    Admin,
    BrandOwner,
    Reseller,
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct User {
    pub id: Principal,
    pub user_role: Option<UserRole>,
    pub is_principal: bool,
    pub is_enabled: bool,
    pub org_ids: Vec<Principal>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub phone_no: Option<String>,
    pub email: Option<String>,
    pub detail_meta: Vec<Metadata>,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(User);

impl Default for User {
    fn default() -> Self {
        User {
            id: api::caller(),
            user_role: None,
            org_ids: Vec::new(),
            is_principal: false,
            is_enabled: true,
            first_name: None,
            last_name: None,
            phone_no: None,
            email: None,
            detail_meta: Vec::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            updated_at: api::time(),
            updated_by: api::caller(), // Default value for Principal
        }
    }
}

impl fmt::Debug for User {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("User")
        .field("id", &self.id)
        .field("user_role", &self.user_role)
        .field("org_ids", &self.org_ids.iter()
                                                    .map(|item| item.to_string())
                                                    .collect::<Vec<String>>().join(","))
        .field("is_principal", &self.is_principal)
        .field("is_enabled", &self.is_enabled)
        .field("first_name", &self.first_name)
        .field("last_name", &self.last_name)
        .field("phone_no", &self.phone_no)
        .field("email", &self.email)
        .field("detail_meta", &self.detail_meta)
        .field("created_at", &self.created_at)
        .field("created_by", &self.created_by)
        .field("updated_at", &self.updated_at)
        .field("updated_by", &self.updated_by)
        .finish()
    }
}

#[derive(CandidType, Deserialize)]
pub struct UserDetailsInput {
    pub first_name: String,
    pub last_name: String,
    pub phone_no: String,
    pub email: String,
    pub detail_meta: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub enum UserResult {
    #[serde(rename = "user")]
    User(User),
    #[serde(rename = "none")]
    None,
    #[serde(rename = "error")]
    Error(ApiError)
}

#[derive(CandidType, Deserialize)]
pub struct ProductReview {
    pub id: Principal,
    pub product_id: Principal,
    pub score: u64,
    pub review_description: String,
    pub metadata: Vec<Metadata>,
    pub created_at: u64,
}

#[derive(CandidType, Serialize, Deserialize, Clone)]
pub struct Reseller {
    pub id: Principal,
    pub org_id: Principal,
    pub name: String,
    pub date_joined: u64,
    pub metadata: Vec<Metadata>,
    pub ecommerce_urls: Vec<Metadata>,
    pub public_key: String,
    pub created_at: u64,
    pub created_by: Principal,
    pub updated_at: u64,
    pub updated_by: Principal,
}
impl_storable_for_candid_type!(Reseller);

impl Default for Reseller {
    fn default() -> Self {
        Reseller {
            id: Principal::anonymous(),
            org_id: Principal::anonymous(),
            name: String::new(),
            date_joined: api::time(),
            metadata: Vec::new(),
            ecommerce_urls: Vec::new(),
            public_key: String::new(),
            created_at: api::time(),
            created_by: api::caller(), // Default value for Principal
            updated_at: api::time(),
            updated_by: api::caller(), // Default value for Principal
        }
    }
}

#[derive(CandidType, Deserialize)]
pub struct ResellerInput {
    pub org_id: Principal,
    pub name: String,
    pub metadata: Vec<Metadata>,
    pub ecommerce_urls: Vec<Metadata>
}

#[derive(CandidType, Deserialize)]
pub enum UniqueCodeResult {
    #[serde(rename = "unique_code")]
    UniqueCode(String),
    #[serde(rename = "error")]
    Error(ApiError)
}

#[derive(CandidType, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub enum ProductVerificationStatus {
    FirstVerification,
    MultipleVerification,
    Invalid
}

#[derive(CandidType, Deserialize)]
pub enum ProductVerificationResult {
    #[serde(rename = "status")]
    Status(ProductVerificationStatus),
    #[serde(rename = "error")]
    Error(ApiError),
}

#[derive(CandidType, Serialize, Deserialize, PartialEq, Eq)]
pub enum VerificationStatus {
    Success,
    Invalid
}

#[derive(CandidType, Deserialize)]
pub struct ResellerVerificationResultRecord {
    pub status: VerificationStatus,
    pub organization: OrganizationPublic,
    pub registered_at: Option<u64>
}

#[derive(CandidType, Deserialize)]
pub enum ResellerVerificationResult {
    #[serde(rename = "result")]
    Result(ResellerVerificationResultRecord),
    #[serde(rename = "error")]
    Error(ApiError),
}

#[derive(CandidType, Deserialize)]
pub enum ProductSerialNumberResult {
    #[serde(rename = "result")]
    Result(ProductSerialNumber),
    #[serde(rename = "error")]
    Error(ApiError),
}

#[derive(CandidType, Deserialize)]
pub struct ProductUniqueCodeResultRecord {
    pub unique_code: String,
    pub print_version: u8,
    pub product_id: Principal,
    pub serial_no: Principal,
    pub created_at: u64,
}

#[derive(CandidType, Deserialize)]
pub enum ProductUniqueCodeResult {
    #[serde(rename = "result")]
    Result(ProductUniqueCodeResultRecord),
    #[serde(rename = "error")]
    Error(ApiError),
}
</file>

<file path="src/backend/src/utils.rs">
use candid::Principal;
use ic_cdk::api::time;
use sha2::{Sha256, Digest};
use std::time::Duration;
use futures::channel::oneshot;
use ic_cdk_timers::set_timer;


pub fn generate_unique_principal(principal: Principal) -> Principal {
    // Combine the principal text and the current time
    let input = format!("{}-{}", principal.to_text(), time());

    // Hash the combined input using SHA-256
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    let result = hasher.finalize();

    // Take the first 29 bytes of the hash and convert it into a Principal
    let principal_bytes: [u8; 29] = result[0..29].try_into().expect("slice with incorrect length");

    Principal::from_slice(&principal_bytes)
}

/// Creates a future that completes after the specified duration.
/// Uses a oneshot channel and `ic_cdk_timers::set_timer`.
pub async fn async_delay(duration: Duration) {
    let (tx, rx) = oneshot::channel::<()>();
    ic_cdk::print(format!("⏱️ Setting timer for {:?}", duration)); // Optional: Log timer setting
    set_timer(duration, move || {
        let _ = tx.send(()); // Signal completion, ignore result
    });
    match rx.await {
        Ok(_) => { /* Timer completed successfully */ }
        Err(e) => {
            // This should ideally not happen in canister environment unless timer logic fails
            ic_cdk::print(format!("❌ ERROR: Timer future cancelled: {:?}", e));
        }
    }
}
</file>

<file path="src/backend/Cargo.toml">
[package]
name = "TrustOrigin_backend"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]
path = "src/lib.rs"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_derive = "1.0"
serde_json = "=1.0.1"
time = { version = "0.3", features = ["macros"] }
candid = "0.10"
ic-cdk = "0.13"
ic-cdk-timers = "0.7" # Feel free to remove this dependency if you don't need timers
ic-stable-structures = "0.6.5"
lazy_static = "1.4.0"
sha2 = "0.10"
rand = "0.8.5"
hex = "0.4.3"
k256 = "0.13.3"
getrandom = { version = "0.2", features = ["custom"] }
futures = "0.3"
</file>

<file path=".gitignore">
# Various IDEs and Editors
.vscode/
.idea/
**/*~

# Mac OSX temporary files
.DS_Store
**/.DS_Store

# dfx temporary files
.dfx/

# rust
target/

# frontend code
node_modules/
dist/
.svelte-kit/

# environment variables
.env

# Cursor Rules
.cursor
</file>

<file path="src/backend/src/api.rs">
use candid::{CandidType, Deserialize, Principal};
use ic_cdk::api;
use serde::Serialize;

use crate::error::{ApiError, ErrorDetails};
use crate::models::{Metadata, Organization, OrganizationPublic, Product, ProductSerialNumber, ProductVerification, Reseller, User, ProductVerificationStatus};

// ====== Common API Structures ======

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct ResponseMetadata {
    pub timestamp: u64,
    pub version: String,
    pub request_id: Option<String>,
}

impl Default for ResponseMetadata {
    fn default() -> Self {
        ResponseMetadata {
            timestamp: api::time(),
            version: "1.0".to_string(),
            request_id: None,
        }
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct PaginationRequest {
    pub page: Option<u32>,
    pub limit: Option<u32>,
}

impl Default for PaginationRequest {
    fn default() -> Self {
        PaginationRequest {
            page: Some(1),
            limit: Some(10),
        }
    }
}

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct PaginationResponse {
    pub page: u32,
    pub limit: u32,
    pub total: u64,
    pub has_more: bool,
}

// ====== Generic API Response Structures ======

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct ApiResponse<T> {
    pub data: Option<T>,
    pub error: Option<ApiError>,
    pub metadata: ResponseMetadata,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        ApiResponse {
            data: Some(data),
            error: None,
            metadata: ResponseMetadata::default(),
        }
    }

    pub fn error(error: ApiError) -> Self {
        ApiResponse {
            data: None,
            error: Some(error),
            metadata: ResponseMetadata::default(),
        }
    }
}

// ===== Organization API Structures =====

#[derive(CandidType, Deserialize)]
pub struct CreateOrganizationRequest {
    pub name: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct OrganizationResponse {
    pub organization: OrganizationPublic,
}

#[derive(CandidType, Deserialize)]
pub struct UpdateOrganizationRequest {
    pub id: Principal,
    pub name: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Deserialize)]
pub struct FindOrganizationsRequest {
    pub name: String,
    pub pagination: Option<PaginationRequest>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct OrganizationsListResponse {
    pub organizations: Vec<OrganizationPublic>,
    pub pagination: Option<PaginationResponse>,
}

// ===== Product API Structures =====

#[derive(CandidType, Deserialize)]
pub struct CreateProductRequest {
    pub name: String,
    pub org_id: Principal,
    pub category: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductResponse {
    pub product: Product,
}

#[derive(CandidType, Deserialize)]
pub struct UpdateProductRequest {
    pub id: Principal,
    pub name: String,
    pub org_id: Principal,
    pub category: String,
    pub description: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Deserialize)]
pub struct ListProductsRequest {
    pub org_id: Principal,
    pub pagination: Option<PaginationRequest>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductsListResponse {
    pub products: Vec<Product>,
    pub pagination: Option<PaginationResponse>,
}

// ===== Product Serial Number API Structures =====

#[derive(CandidType, Deserialize)]
pub struct CreateProductSerialNumberRequest {
    pub product_id: Principal,
    pub user_serial_no: Option<String>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductSerialNumberResponse {
    pub serial_number: ProductSerialNumber,
}

#[derive(CandidType, Deserialize)]
pub struct ListProductSerialNumbersRequest {
    pub organization_id: Option<Principal>,
    pub product_id: Option<Principal>,
    pub pagination: Option<PaginationRequest>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductSerialNumbersListResponse {
    pub serial_numbers: Vec<ProductSerialNumber>,
    pub pagination: Option<PaginationResponse>,
}

// ===== Product Verification API Structures =====

#[derive(CandidType, Deserialize)]
pub struct VerifyProductRequest {
    pub product_id: Principal,
    pub serial_no: Principal,
    pub print_version: u8,
    pub unique_code: String,
    pub metadata: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductVerificationResponse {
    pub verification: ProductVerification,
}

#[derive(CandidType, Deserialize)]
pub struct ListProductVerificationsRequest {
    pub organization_id: Option<Principal>,
    pub product_id: Option<Principal>,
    pub serial_number: Option<Principal>,
    pub pagination: Option<PaginationRequest>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductVerificationsListResponse {
    pub verifications: Vec<ProductVerification>,
    pub pagination: Option<PaginationResponse>,
}

// ===== Product Verification Enhanced API Structures =====

#[derive(CandidType, Deserialize)]
pub struct VerifyProductEnhancedRequest {
    pub product_id: Principal,
    pub serial_no: Principal,
    pub print_version: u8,
    pub unique_code: String,
    pub metadata: Vec<Metadata>,
    pub timestamp: Option<u64>,  // Client timestamp for replay attack prevention
    pub nonce: Option<String>,   // Optional nonce for additional security
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ProductVerificationEnhancedResponse {
    pub status: ProductVerificationStatus,
    pub verification: Option<ProductVerification>,
    pub rewards: Option<VerificationRewards>,
    pub expiration: Option<u64>,
}

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct VerificationRewards {
    pub points: u32,
    pub is_first_verification: bool,
    pub special_reward: Option<String>,
    pub reward_description: Option<String>,
}

// ===== Rate Limiting Structures =====

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct RateLimitInfo {
    pub remaining_attempts: u32,
    pub reset_time: u64,
    pub current_window_start: u64,
}

#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct VerificationAttempt {
    pub user_id: Principal,
    pub product_id: Principal,
    pub serial_no: Principal,
    pub timestamp: u64,
    pub success: bool,
}

// ===== User API Structures =====

#[derive(CandidType, Deserialize)]
pub struct RegisterUserRequest {
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub email: Option<String>,
    pub phone_no: Option<String>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct UserResponse {
    pub user: User,
}

#[derive(CandidType, Deserialize)]
pub struct UpdateUserRequest {
    pub id: Principal,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub email: Option<String>,
    pub phone_no: Option<String>,
    pub detail_meta: Option<Vec<Metadata>>,
}

// ===== Reseller API Structures =====

#[derive(CandidType, Deserialize)]
pub struct CreateResellerRequest {
    pub org_id: Principal,
    pub name: String,
    pub metadata: Vec<Metadata>,
    pub ecommerce_urls: Vec<Metadata>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ResellerResponse {
    pub reseller: Reseller,
}

#[derive(CandidType, Deserialize)]
pub struct GenerateResellerUniqueCodeRequest {
    pub reseller_id: Principal,
    // Optional context or nonce to include in the code generation
    pub context: Option<String>,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ResellerUniqueCodeResponse {
    pub unique_code: String,
    pub reseller_id: Principal,
    pub timestamp: u64,
    pub context: Option<String>,
}

#[derive(CandidType, Deserialize)]
pub struct VerifyResellerRequest {
    pub reseller_id: Principal,
    pub unique_code: String,
    pub timestamp: u64, // Timestamp from the generated code
    pub context: Option<String>, // Context must match if provided during generation
}

#[derive(CandidType, Serialize, Deserialize, Debug, Clone)]
pub enum ResellerVerificationStatus {
    Success,
    InvalidCode,
    ExpiredCode,
    ReplayAttackDetected,
    ResellerNotFound,
    OrganizationNotFound,
    InternalError,
}

#[derive(CandidType, Serialize, Deserialize)]
pub struct ResellerVerificationResponse {
    pub status: ResellerVerificationStatus,
    pub organization: Option<OrganizationPublic>,
    pub reseller: Option<Reseller>,
}

// Function to apply pagination to any vector of items
pub fn paginate<T: Clone>(
    items: Vec<T>, 
    request: &PaginationRequest
) -> (Vec<T>, PaginationResponse) {
    let page = request.page.unwrap_or(1);
    let limit = request.limit.unwrap_or(10);
    
    let start = ((page - 1) * limit) as usize;
    let end = (page * limit) as usize;
    
    let total = items.len() as u64;
    let paginated_items = if start < items.len() {
        items[start..std::cmp::min(end, items.len())].to_vec()
    } else {
        vec![]
    };
    
    let pagination = PaginationResponse {
        page,
        limit,
        total,
        has_more: end < items.len(),
    };
    
    (paginated_items, pagination)
}
</file>

<file path="src/backend/src/auth.rs">
use candid::{CandidType, Principal, Deserialize};
use serde::Serialize;
use std::collections::HashSet;

use crate::error::ApiError;
use crate::global_state::{ORGANIZATIONS, PRODUCTS, USERS};
use crate::models::{Metadata, Organization, UserRole};
use ic_cdk::api;

// Define permission types
#[derive(CandidType, Serialize, Deserialize, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Permission {
    ReadOrganization,
    WriteOrganization,
    ReadProduct,
    WriteProduct,
    ReadUser,
    WriteUser,
    ReadReseller,
    WriteReseller,
    ManageVerifications,
    AdminAccess,
}

// Define audit log entry
#[derive(CandidType, Serialize, Deserialize, Clone, Debug)]
pub struct AuditLogEntry {
    pub user_id: Principal,
    pub action: String,
    pub resource_type: String,
    pub resource_id: Principal,
    pub timestamp: u64,
    pub metadata: Vec<Metadata>,
    pub success: bool,
}

// Get permissions based on role
pub fn get_role_permissions(role: &UserRole) -> HashSet<Permission> {
    let mut permissions = HashSet::new();
    
    match role {
        UserRole::Admin => {
            // Admins have all permissions
            permissions.insert(Permission::ReadOrganization);
            permissions.insert(Permission::WriteOrganization);
            permissions.insert(Permission::ReadProduct);
            permissions.insert(Permission::WriteProduct);
            permissions.insert(Permission::ReadUser);
            permissions.insert(Permission::WriteUser);
            permissions.insert(Permission::ReadReseller);
            permissions.insert(Permission::WriteReseller);
            permissions.insert(Permission::ManageVerifications);
            permissions.insert(Permission::AdminAccess);
        },
        UserRole::BrandOwner => {
            // Brand owners can manage their own organizations and products
            permissions.insert(Permission::ReadOrganization);
            permissions.insert(Permission::WriteOrganization);
            permissions.insert(Permission::ReadProduct);
            permissions.insert(Permission::WriteProduct);
            permissions.insert(Permission::ReadUser);
            permissions.insert(Permission::WriteUser);
            permissions.insert(Permission::ReadReseller);
            permissions.insert(Permission::WriteReseller);
            permissions.insert(Permission::ManageVerifications);
        },
        UserRole::Reseller => {
            // Resellers have limited permissions
            permissions.insert(Permission::ReadOrganization);
            permissions.insert(Permission::ReadProduct);
            permissions.insert(Permission::ReadReseller);
            permissions.insert(Permission::ManageVerifications);
        }
    }
    
    permissions
}

// Check if user has required permission - take a borrowed permission instead of moving it
pub fn check_permission(user_id: Principal, required_permission: &Permission) -> Result<(), ApiError> {
    let user_opt = USERS.with(|users_refcell| users_refcell.borrow().get(&user_id));
    
    if user_opt.is_none() {
        return Err(ApiError::not_found("User not found!"));
    }
    
    let user = user_opt.unwrap();
    
    // Check if user has a role
    if user.user_role.is_none() {
        return Err(ApiError::unauthorized("User has no assigned role"));
    }
    
    // Get permissions for the user's role
    let permissions = get_role_permissions(&user.user_role.unwrap());
    
    // Check if the user has the required permission
    if !permissions.contains(required_permission) {
        return Err(ApiError::unauthorized(&format!("User lacks permission: {:?}", required_permission)));
    }
    
    Ok(())
}

// Check if user belongs to an organization and has permission
pub fn authorize_for_organization(
    user_id: Principal, 
    org_id: Principal, 
    permission: Permission
) -> Result<Organization, ApiError> {
    // First check user has the required permission based on role
    check_permission(user_id, &permission)?;
    
    // Then check user is associated with the organization
    let user_opt = USERS.with(|users_refcell| users_refcell.borrow().get(&user_id));
    
    if user_opt.is_none() {
        return Err(ApiError::not_found("User not found!"));
    }
    
    let user = user_opt.unwrap();
    
    let organization_opt = ORGANIZATIONS.with(|orgs_refcell| orgs_refcell.borrow().get(&org_id));
    
    if organization_opt.is_none() {
        return Err(ApiError::not_found("Organization not found!"));
    }
    
    let organization = organization_opt.unwrap();
    
    // Check user belongs to this organization
    if !user.org_ids.contains(&org_id) {
        return Err(ApiError::unauthorized("User is not authorized for this organization!"));
    }
    
    // Log the access (simplified for now, in real implementation would add to a stable collection)
    let _audit_log = AuditLogEntry {
        user_id,
        action: format!("Access with permission: {:?}", permission),
        resource_type: "Organization".to_string(),
        resource_id: org_id,
        timestamp: api::time(),
        metadata: vec![],
        success: true,
    };
    
    // TODO: Store audit log in a stable collection
    
    Ok(organization.clone())
}

// Legacy function for backward compatibility
pub fn authorize_user_organization(user_id: Principal, org_id: Principal) -> Result<Organization, ApiError> {
    authorize_for_organization(user_id, org_id, Permission::ReadOrganization)
}

// Authorized access to a product
pub fn authorize_for_product(
    user_id: Principal,
    product_id: Principal,
    permission: Permission
) -> Result<(), ApiError> {
    // First check user has the required permission
    check_permission(user_id, &permission)?;
    
    // Get the product to find its organization
    let product_opt = PRODUCTS.with(|products_refcell| products_refcell.borrow().get(&product_id));
    
    if product_opt.is_none() {
        return Err(ApiError::not_found("Product not found!"));
    }
    
    let product = product_opt.unwrap();
    
    // Now check user has access to the product's organization
    let user_opt = USERS.with(|users_refcell| users_refcell.borrow().get(&user_id));
    
    if user_opt.is_none() {
        return Err(ApiError::not_found("User not found!"));
    }
    
    let user = user_opt.unwrap();
    
    // Check user belongs to this product's organization
    if !user.org_ids.contains(&product.org_id) {
        return Err(ApiError::unauthorized("User is not authorized for this product's organization!"));
    }
    
    // Log the access
    let _audit_log = AuditLogEntry {
        user_id,
        action: format!("Access with permission: {:?}", permission),
        resource_type: "Product".to_string(),
        resource_id: product_id,
        timestamp: api::time(),
        metadata: vec![],
        success: true,
    };
    
    // TODO: Store audit log in a stable collection
    
    Ok(())
}

// Check if caller is admin
pub fn ensure_admin(user_id: Principal) -> Result<(), ApiError> {
    let user_opt = USERS.with(|users_refcell| users_refcell.borrow().get(&user_id));
    
    if user_opt.is_none() {
        return Err(ApiError::not_found("User not found!"));
    }
    
    let user = user_opt.unwrap();
    
    // Check if user has admin role
    match user.user_role {
        Some(UserRole::Admin) => Ok(()),
        _ => Err(ApiError::unauthorized("Admin access required"))
    }
}
</file>

<file path="src/backend/src/lib.rs">
pub mod global_state;
pub mod models;
pub mod utils;
pub mod icp;
pub mod error;
pub mod auth;
pub mod api;
pub mod rate_limiter;
pub mod rewards;
</file>

<file path="src/backend/src/global_state.rs">
use candid::{encode_one, decode_one, Principal, CandidType, Deserialize};
use ic_cdk::{init, post_upgrade};
use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::{storable::Bound, DefaultMemoryImpl, StableBTreeMap, StableCell, Storable};
use rand::rngs::StdRng;
use rand::{RngCore, SeedableRng};
use getrandom::register_custom_getrandom;
use std::borrow::Cow;
use std::time::Duration;
use std::{cell::RefCell};
use serde::Serialize;
use crate::models::{Organization, Product, User, Reseller, ProductSerialNumber, ProductVerification};

// Define Memory IDs for stable structures
const ORGANIZATION_MEM_ID: MemoryId = MemoryId::new(0);
const PRODUCT_MEM_ID: MemoryId = MemoryId::new(1);
const USER_MEM_ID: MemoryId = MemoryId::new(2);
const RESELLER_MEM_ID: MemoryId = MemoryId::new(3);
const PRODUCT_SERIAL_NUMBER_MEM_ID: MemoryId = MemoryId::new(4);
const PRODUCT_VERIFICATION_MEM_ID: MemoryId = MemoryId::new(5);
// Reserve IDs 6, 7, 8, 9 for rate_limiter and rewards
const CONFIG_OPENAI_KEY_MEM_ID: MemoryId = MemoryId::new(10);
const CONFIG_SCRAPER_URL_MEM_ID: MemoryId = MemoryId::new(11);

// Type aliases for memory and stable structures
type Memory = VirtualMemory<DefaultMemoryImpl>;

// Wrapper struct for Vec<u8> to implement Storable (solves orphan rule)
#[derive(CandidType, Serialize, Deserialize, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]
pub struct StorableBytes(pub Vec<u8>);

impl Storable for StorableBytes {
    fn to_bytes(&self) -> Cow<[u8]> {
        Cow::Borrowed(&self.0)
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        StorableBytes(bytes.into_owned())
    }

    const BOUND: Bound = Bound::Unbounded;
}

// Newtype wrapper for String to implement Storable
#[derive(CandidType, Serialize, Deserialize, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]
pub struct StorableString(pub String);

impl Storable for StorableString {
    fn to_bytes(&self) -> Cow<[u8]> {
        // Borrow the inner string's bytes
        Cow::Borrowed(self.0.as_bytes())
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        // Convert bytes back to String and wrap
        StorableString(String::from_utf8(bytes.into_owned()).expect("Invalid UTF-8 for String"))
    }

    const BOUND: Bound = Bound::Unbounded; // Assuming unbounded for simplicity
}

thread_local! {
    static RNG: RefCell<Option<StdRng>> = RefCell::new(None);

    pub static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

    pub static ORGANIZATIONS: RefCell<StableBTreeMap<Principal, Organization, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(ORGANIZATION_MEM_ID)))
    );

    pub static PRODUCTS: RefCell<StableBTreeMap<Principal, Product, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(PRODUCT_MEM_ID)))
    );

    pub static USERS: RefCell<StableBTreeMap<Principal, User, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(USER_MEM_ID)))
    );

    pub static RESELLERS: RefCell<StableBTreeMap<Principal, Reseller, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(RESELLER_MEM_ID)))
    );

    pub static PRODUCT_SERIAL_NUMBERS: RefCell<StableBTreeMap<Principal, StorableBytes, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(PRODUCT_SERIAL_NUMBER_MEM_ID)))
    );

    pub static PRODUCT_VERIFICATIONS: RefCell<StableBTreeMap<Principal, StorableBytes, Memory>> = RefCell::new(
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(PRODUCT_VERIFICATION_MEM_ID)))
    );

    // Configuration StableCells - Use StorableString instead of String
    pub static CONFIG_OPENAI_API_KEY: RefCell<StableCell<StorableString, Memory>> = RefCell::new(
        StableCell::init(MEMORY_MANAGER.with(|m| m.borrow().get(CONFIG_OPENAI_KEY_MEM_ID)), StorableString::default()) // Use default StorableString
            .expect("Failed to initialize OpenAI key config cell")
    );
    pub static CONFIG_SCRAPER_URL: RefCell<StableCell<StorableString, Memory>> = RefCell::new(
        StableCell::init(MEMORY_MANAGER.with(|m| m.borrow().get(CONFIG_SCRAPER_URL_MEM_ID)), StorableString::default()) // Use default StorableString
            .expect("Failed to initialize scraper URL config cell")
    );
}

pub fn decode_product_serial_numbers(storable_bytes: &StorableBytes) -> Vec<ProductSerialNumber> {
    decode_one(&storable_bytes.0).expect("Failed to decode Vec<ProductSerialNumber>")
}

pub fn encode_product_serial_numbers(data: &Vec<ProductSerialNumber>) -> StorableBytes {
    StorableBytes(encode_one(data).expect("Failed to encode Vec<ProductSerialNumber>"))
}

pub fn decode_product_verifications(storable_bytes: &StorableBytes) -> Vec<ProductVerification> {
    decode_one(&storable_bytes.0).expect("Failed to decode Vec<ProductVerification>")
}

pub fn encode_product_verifications(data: &Vec<ProductVerification>) -> StorableBytes {
    StorableBytes(encode_one(data).expect("Failed to encode Vec<ProductVerification>"))
}

fn _restart_rng() {
    let _timer_id = ic_cdk_timers::set_timer(Duration::ZERO, || ic_cdk::spawn(async {
        let (seed,): ([u8; 32],) = ic_cdk::call(Principal::management_canister(), "raw_rand", ()).await.unwrap();
        ic_cdk::println!("Got seed");
        RNG.with(|rng| *rng.borrow_mut() = Some(StdRng::from_seed(seed)));
    }));
    ic_cdk::println!("registered timer {:?}", _timer_id);
}

#[post_upgrade]
fn post_upgrade() {
    _restart_rng();
}

#[init]
fn init() {
    _restart_rng();
}

fn custom_getrandom(buf: &mut [u8]) -> Result<(), getrandom::Error> {
    ic_cdk::println!("custom_getrandom");
    RNG.with(|rng| rng.borrow_mut().as_mut().unwrap().fill_bytes(buf));
    Ok(())
}
register_custom_getrandom!(custom_getrandom);
</file>

<file path="src/backend/src/icp.rs">
use candid::Principal;
use ic_cdk::{api, query, update};
use k256::{
    ecdsa::{
        signature::{Signer, Verifier},
        Signature, SigningKey, VerifyingKey,
    },
    elliptic_curve::sec1::ToEncodedPoint,
    sha2::{Digest, Sha256},
    EncodedPoint, SecretKey,
};
use crate::auth::{authorize_for_organization, ensure_admin, Permission};
use crate::error::ApiError;
use crate::models::{Metadata, Organization, OrganizationInput, OrganizationPublic, OrganizationResult, PrivateKeyResult, Product, ProductInput, ProductResult, ProductSerialNumber, ProductSerialNumberResult, ProductUniqueCodeResult, ProductUniqueCodeResultRecord, ProductVerification, ProductVerificationResult, ProductVerificationStatus, Reseller, ResellerInput, ResellerVerificationResult, UniqueCodeResult, User, UserDetailsInput, UserResult, UserRole};
use crate::utils::generate_unique_principal;
use crate::{
    global_state::{
        decode_product_serial_numbers, decode_product_verifications, encode_product_serial_numbers,
        encode_product_verifications, ORGANIZATIONS, PRODUCTS, PRODUCT_SERIAL_NUMBERS,
        PRODUCT_VERIFICATIONS, RESELLERS, USERS,
        CONFIG_OPENAI_API_KEY, CONFIG_SCRAPER_URL, StorableString,
    },
    models::{ResellerVerificationResultRecord, VerificationStatus},
};

use ic_cdk::api::management_canister::http_request::{
    http_request, CanisterHttpRequestArgument, HttpHeader, HttpMethod, HttpResponse, TransformArgs,
    TransformContext, TransformFunc,
};

use serde_json::{self, Value};
use rand::prelude::StdRng;
use k256::elliptic_curve::rand_core::SeedableRng;
use ic_cdk_timers::set_timer;
use std::time::Duration;
use std::convert::TryInto;

use crate::api::{
    ApiResponse, CreateOrganizationRequest, FindOrganizationsRequest, OrganizationResponse,
    UpdateOrganizationRequest, OrganizationsListResponse, PaginationRequest, paginate,
    VerifyProductEnhancedRequest, ProductVerificationEnhancedResponse, RateLimitInfo,
    GenerateResellerUniqueCodeRequest, ResellerUniqueCodeResponse, VerifyResellerRequest,
    ResellerVerificationResponse, ResellerVerificationStatus, UserResponse, ProductResponse
};
use crate::rate_limiter;
use crate::rewards;
use crate::utils;

#[query]
pub fn get_organization_by_id(id: Principal) -> OrganizationResult {
    // Check for permission to read organization
    let user_id = ic_cdk::caller();
    let user_opt = USERS.with(|users| users.borrow().get(&user_id));

    // If user exists and has a role, check permissions
    if let Some(user) = user_opt {
        if let Some(role) = &user.user_role {
            // Check if user belongs to this organization or is an admin
            if !user.org_ids.contains(&id) && !matches!(role, UserRole::Admin) {
                return OrganizationResult::Error(ApiError::unauthorized(
                    "User does not have access to this organization",
                ));
            }
        } else {
            // If user has no role, they can't access organizations
            return OrganizationResult::Error(ApiError::unauthorized("User has no role assigned"));
        }
    }

    ORGANIZATIONS.with(|orgs| match orgs.borrow().get(&id) {
        Some(org) => OrganizationResult::Organization(OrganizationPublic::from(org.clone())),
        None => OrganizationResult::Error(ApiError::not_found(&format!(
            "Organization with ID {} not found",
            id
        ))),
    })
}

#[query]
pub fn get_organization_by_id_v2(id: Principal) -> ApiResponse<OrganizationResponse> {
    // Check for permission to read organization
    let user_id = ic_cdk::caller();
    let user_opt = USERS.with(|users| users.borrow().get(&user_id));

    // If user exists and has a role, check permissions
    if let Some(user) = user_opt {
        if let Some(role) = &user.user_role {
            // Check if user belongs to this organization or is an admin
            if !user.org_ids.contains(&id) && !matches!(role, UserRole::Admin) {
                return ApiResponse::error(ApiError::unauthorized(
                    "User does not have access to this organization",
                ));
            }
        } else {
            // If user has no role, they can't access organizations
            return ApiResponse::error(ApiError::unauthorized("User has no role assigned"));
        }
    } else {
        return ApiResponse::error(ApiError::unauthorized("User not found"));
    }

    ORGANIZATIONS.with(|orgs| match orgs.borrow().get(&id) {
        Some(org) => ApiResponse::success(OrganizationResponse {
            organization: OrganizationPublic::from(org.clone()),
        }),
        None => ApiResponse::error(ApiError::not_found(&format!(
            "Organization with ID {} not found",
            id
        ))),
    })
}

#[update]
pub fn create_organization(input: OrganizationInput) -> OrganizationPublic {
    // For creation, we don't need to check existing permissions since this creates a brand new org
    // However, we should check if the user has a registered account at minimum
    let caller = api::caller();
    let user_exists = USERS.with(|users| users.borrow().get(&caller).is_some());

    if !user_exists {
        // Register the user automatically
        let _ = register();
    }

    let id = generate_unique_principal(Principal::anonymous()); // Generate a unique ID for the organization
    // Generate ECDSA keys for demonstration
    let mut rng = StdRng::from_entropy();
    let signing_key = SigningKey::random(&mut rng);
    let organization = Organization {
        id,
        name: input.name,
        private_key: hex::encode(&signing_key.to_bytes()),
        description: input.description,
        metadata: input.metadata,
        ..Default::default()
    };

    ORGANIZATIONS.with(|orgs| {
        orgs.borrow_mut().insert(id, organization.clone());
    });

    OrganizationPublic::from(organization)
}

#[update]
pub fn update_organization(id: Principal, input: OrganizationInput) -> OrganizationResult {
    // Check that user has write permission for this organization
    let result = authorize_for_organization(ic_cdk::caller(), id, Permission::WriteOrganization);
    if result.is_err() {
        return OrganizationResult::Error(result.err().unwrap());
    }

    ORGANIZATIONS.with(|orgs| {
        let mut orgs_mut = orgs.borrow_mut();
        match orgs_mut.get(&id) {
            Some(org) => {
                // Create a new organization with updated fields
                let updated_org = Organization {
                    name: input.name,
                    description: input.description,
                    metadata: input.metadata,
                    updated_at: api::time(),
                    updated_by: api::caller(),
                    ..org.clone()
                };

                // Insert the updated organization
                orgs_mut.insert(id, updated_org.clone());

                OrganizationResult::Organization(OrganizationPublic::from(updated_org))
            }
            None => OrganizationResult::Error(ApiError::not_found(&format!(
                "Organization with ID {} not found",
                id
            ))),
        }
    })
}

#[query]
pub fn get_organization_private_key(org_id: Principal) -> PrivateKeyResult {
    // Accessing private key requires higher permission level (write access to the organization)
    let result = authorize_for_organization(api::caller(), org_id, Permission::WriteOrganization);
    match result {
        Ok(org) => PrivateKeyResult::Key(org.private_key),
        Err(err) => PrivateKeyResult::Error(err),
    }
}

#[query]
pub fn find_organizations_by_name(name: String) -> Vec<OrganizationPublic> {
    let filter = name.trim().to_lowercase();
    let caller = ic_cdk::caller();

    // Get user to check role and permissions
    let user_opt = USERS.with(|users| users.borrow().get(&caller));

    ORGANIZATIONS.with(|orgs| {
        let orgs_borrow = orgs.borrow();

        // If user is admin, they can see all organizations
        if let Some(user) = &user_opt {
            if let Some(role) = &user.user_role {
                if matches!(role, UserRole::Admin) {
                    return orgs_borrow
                        .iter()
                        .filter(|(_, org)| org.name.to_lowercase().contains(&filter))
                        .map(|(_, org)| OrganizationPublic::from(org.clone()))
                        .collect();
                }
            }

            // For non-admin users, only show organizations they belong to
            return orgs_borrow
                .iter()
                .filter(|(org_id, org)| {
                    org.name.to_lowercase().contains(&filter) && user.org_ids.contains(org_id)
                })
                .map(|(_, org)| OrganizationPublic::from(org.clone()))
                .collect();
        }

        // If no user found or no role, return empty list
        vec![]
    })
}

#[update]
pub fn create_product(input: ProductInput) -> ProductResult {
    // Use enhanced authorization that checks for write permission
    let authorization_result =
        authorize_for_organization(api::caller(), input.org_id, Permission::WriteProduct);
    if authorization_result.is_err() {
        return ProductResult::Error(authorization_result.err().unwrap());
    }

    let organization = authorization_result.ok().unwrap();
    let id = generate_unique_principal(Principal::anonymous()); // Generate a unique ID for the product

    let private_key_bytes = hex::decode(&organization.private_key);
    if private_key_bytes.is_err() {
        return ProductResult::Error(ApiError::invalid_input(&format!(
            "Invalid private key format: {}",
            private_key_bytes.err().unwrap()
        )));
    }
    let private_key = SigningKey::from_slice(&private_key_bytes.unwrap().as_slice());
    if private_key.is_err() {
        return ProductResult::Error(ApiError::internal_error(&format!(
            "Failed to process private key: {}",
            private_key.err().unwrap()
        )));
    }
    let private_key_unwrapped = private_key.unwrap();
    let public_key = private_key_unwrapped.verifying_key();
    let product = Product {
        id,
        org_id: input.org_id,
        name: input.name,
        category: input.category,
        description: input.description,
        metadata: input.metadata,
        public_key: hex::encode(public_key.to_encoded_point(false).as_bytes()),
        ..Default::default()
    };

    PRODUCTS.with(|products| {
        products.borrow_mut().insert(id, product.clone());
    });

    ProductResult::Product(product)
}

#[query]
pub fn list_products(org_id: Principal) -> Vec<Product> {
    // Check for read product permission within the organization
    let authorization_result =
        authorize_for_organization(api::caller(), org_id, Permission::ReadProduct);
    if authorization_result.is_err() {
        return vec![];
    }

    PRODUCTS.with(|products| {
        products
            .borrow()
            .iter()
            .filter(|(_, product)| product.org_id == org_id)
            .map(|(_, product)| product.clone())
            .collect()
    })
}

#[query]
pub fn get_product_by_id(id: Principal) -> ProductResult {
    let product_opt = PRODUCTS.with(|products| products.borrow().get(&id));

    if product_opt.is_none() {
        return ProductResult::None;
    }

    let product = product_opt.unwrap();

    // Check for read product permission
    let authorization_result =
        authorize_for_organization(api::caller(), product.org_id, Permission::ReadProduct);
    if authorization_result.is_err() {
        return ProductResult::Error(authorization_result.err().unwrap());
    }

    ProductResult::Product(product)
}

#[update]
pub fn update_product(id: Principal, input: ProductInput) -> ProductResult {
    // Get the product first to check ownership and permissions
    let product_opt = PRODUCTS.with(|products| products.borrow().get(&id));

    if product_opt.is_none() {
        return ProductResult::Error(ApiError::not_found(&format!(
            "Product with ID {} not found",
            id
        )));
    }

    let product = product_opt.unwrap();

    // Check for write product permission
    let authorization_result =
        authorize_for_organization(api::caller(), product.org_id, Permission::WriteProduct);
    if authorization_result.is_err() {
        return ProductResult::Error(authorization_result.err().unwrap());
    }

    // Check that the user is not trying to move the product to a different organization they don't have access to
    if product.org_id != input.org_id {
        let new_org_auth =
            authorize_for_organization(api::caller(), input.org_id, Permission::WriteProduct);
        if new_org_auth.is_err() {
            return ProductResult::Error(ApiError::unauthorized(
                "Cannot move product to an organization you don't have write access to",
            ));
        }
    }

    PRODUCTS.with(|products| {
        let mut products_mut = products.borrow_mut();

        // Create an updated product
        let updated_product = Product {
            org_id: input.org_id,
            name: input.name,
            description: input.description,
            category: input.category,
            metadata: input.metadata,
            updated_at: api::time(),
            updated_by: api::caller(),
            ..product.clone()
        };

        // Insert the updated product
        products_mut.insert(id, updated_product.clone());

        ProductResult::Product(updated_product)
    })
}

#[update]
pub fn register() -> User {
    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();
        let caller = api::caller();

        // Return an existing user if found
        if let Some(existing_user) = users_mut.get(&caller) {
            return existing_user.clone();
        }

        // Create a new user
        let user = User {
            id: caller,
            is_principal: users_mut.is_empty(),
            ..Default::default()
        };

        users_mut.insert(caller, user.clone());
        user
    })
}

#[query]
pub fn get_user_by_id(id: Principal) -> Option<User> {
    // TODO access control
    USERS.with(|users| {
        let users_ref = users.borrow();
        match users_ref.get(&id) {
            Some(user) => Some(user.clone()),
            None => None,
        }
    })
}

#[query]
pub fn whoami() -> Option<User> {
    USERS.with(|users| {
        let users_ref = users.borrow();
        let caller = api::caller();
        match users_ref.get(&caller) {
            Some(user) => Some(user.clone()),
            None => None,
        }
    })
}

#[update]
pub fn update_self_details(input: UserDetailsInput) -> UserResult {
    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();
        let caller = api::caller();

        if let Some(user) = users_mut.get(&caller) {
            // Create an updated user
            let updated_user = User {
                first_name: Some(input.first_name),
                last_name: Some(input.last_name),
                phone_no: Some(input.phone_no),
                email: Some(input.email),
                detail_meta: input.detail_meta,
                updated_at: api::time(),
                updated_by: caller,
                ..user.clone()
            };

            // Insert updated user
            users_mut.insert(caller, updated_user.clone());

            UserResult::User(updated_user)
        } else {
            UserResult::Error(ApiError::not_found("User not found"))
        }
    })
}

// DEBUG ONLY
#[update]
pub fn set_self_role(role: UserRole) -> UserResult {
    let caller = api::caller();

    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();

        if let Some(user) = users_mut.get(&caller) {
            // Create an updated user with a new role
            // Only allow role assignment if user doesn't already have a role or is an admin
            if user.user_role.is_some()
                && !matches!(user.user_role.as_ref().unwrap(), UserRole::Admin)
            {
                return UserResult::Error(ApiError::unauthorized(
                    "You already have a role assigned and cannot change it",
                ));
            }

            // Admin role can only be assigned by another admin
            if matches!(role, UserRole::Admin) {
                let caller_is_admin = USERS.with(|users| {
                    if let Some(caller_user) = users.borrow().get(&caller) {
                        if let Some(caller_role) = &caller_user.user_role {
                            return matches!(caller_role, UserRole::Admin);
                        }
                    }
                    false
                });

                if !caller_is_admin {
                    return UserResult::Error(ApiError::unauthorized(
                        "Only administrators can assign admin roles",
                    ));
                }
            }

            let updated_user = User {
                user_role: Some(role),
                updated_at: api::time(),
                updated_by: caller,
                ..user.clone()
            };

            // Insert updated user
            users_mut.insert(caller, updated_user.clone());

            UserResult::User(updated_user)
        } else {
            UserResult::Error(ApiError::not_found("User not found"))
        }
    })
}

#[update]
pub fn register_as_organization(input: OrganizationInput) -> UserResult {
    // First, create the organization
    let org_public = create_organization(input);

    // Then update the user
    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();
        let caller = api::caller();

        if let Some(user) = users_mut.get(&caller) {
            // Create an updated user with organization access
            let mut org_ids = user.org_ids.clone();
            org_ids.push(org_public.id);

            let updated_user = User {
                org_ids,
                user_role: Some(UserRole::BrandOwner),
                updated_at: api::time(),
                updated_by: caller,
                ..user.clone()
            };

            // Insert updated user
            users_mut.insert(caller, updated_user.clone());

            UserResult::User(updated_user)
        } else {
            UserResult::Error(ApiError::not_found("User not found"))
        }
    })
}

#[update]
pub fn register_as_reseller_v2(input: ResellerInput) -> ApiResponse<UserResponse> {
    let caller = api::caller();

    // --- 1. Input Validation ---
    if input.name.trim().is_empty() {
        return ApiResponse::error(ApiError::invalid_input("Reseller name cannot be empty"));
    }
    // TODO: Add validation for metadata/ecommerce_urls length/content if needed

    // --- 2. User Checks ---
    let user_opt = USERS.with(|users| users.borrow().get(&caller));

    if user_opt.is_none() {
        return ApiResponse::error(ApiError::not_found(&format!(
            "User with principal {} not found. Please register first.",
            caller
        )));
    }

    let user = user_opt.unwrap(); // Safe to unwrap due to check above

    if user.user_role.is_some() {
        return ApiResponse::error(ApiError::unauthorized(
            "User already has an assigned role (e.g., BrandOwner or Admin)",
        ));
    }

    // --- 3. Organization Checks ---
    let org_opt = ORGANIZATIONS.with(|orgs| orgs.borrow().get(&input.org_id));

    if org_opt.is_none() {
        return ApiResponse::error(ApiError::not_found(&format!(
            "Organization with ID {} not found",
            input.org_id
        )));
    }

    let organization = org_opt.unwrap(); // Safe to unwrap

    // --- 4. Key Processing ---
    let private_key_bytes = match hex::decode(&organization.private_key) {
        Ok(bytes) => bytes,
        Err(e) => {
            ic_cdk::print(format!("❌ ERROR: Failed to decode private key for org {}: {}", organization.id, e));
            return ApiResponse::error(ApiError::internal_error(
                "Failed to process organization secret key",
            ));
        }
    };

    let private_key = match SecretKey::from_slice(&private_key_bytes) { // Note: Using SecretKey, assuming this is correct for Reseller key generation
        Ok(key) => key,
        Err(e) => {
             ic_cdk::print(format!("❌ ERROR: Failed to create secret key from slice for org {}: {}", organization.id, e));
            return ApiResponse::error(ApiError::internal_error(
                "Malformed secret key for organization",
            ));
        }
    };
    
    // Derive public key - assuming reseller needs its own keypair based on org's key?
    // Or should the reseller use the org's public key directly?
    // Let's stick to the previous logic: generate public key from org private key for now.
    let public_key = private_key.public_key();
    let public_key_hex = hex::encode(public_key.to_encoded_point(false).as_bytes());

    // --- 5. Reseller Creation ---
    let reseller_id = generate_unique_principal(Principal::anonymous());

    let reseller = Reseller {
        id: reseller_id,
        org_id: input.org_id,
        name: input.name,
        ecommerce_urls: input.ecommerce_urls,
        metadata: input.metadata,
        public_key: public_key_hex, // Storing derived public key
        created_at: api::time(),
        created_by: caller,
        updated_at: api::time(),
        updated_by: caller,
        ..Default::default() // Ensure other fields like date_joined are handled
    };

    RESELLERS.with(|resellers| {
        resellers.borrow_mut().insert(reseller_id, reseller);
    });

    // --- 6. Update User Role ---
    let updated_user = User {
        user_role: Some(UserRole::Reseller),
        org_ids: vec![input.org_id], // Associate user with this org
        updated_at: api::time(),
        updated_by: caller,
        ..user.clone()
    };

    USERS.with(|users| {
        users.borrow_mut().insert(caller, updated_user.clone());
    });
    
    // --- 7. Success --- 
    ApiResponse::success(UserResponse { user: updated_user })
}

#[update]
pub fn create_user(id: Principal, input: UserDetailsInput) -> UserResult {
    // Only admins can create other users
    let caller = api::caller();
    let auth_result = ensure_admin(caller);

    if auth_result.is_err() {
        return UserResult::Error(ApiError::unauthorized(
            "Only administrators can create users",
        ));
    }

    let mut user_exists = false;

    USERS.with(|users| {
        user_exists = users.borrow().get(&id).is_some();
    });

    if user_exists {
        return UserResult::Error(ApiError::already_exists("User already exists"));
    }

    let user = User {
        id,
        is_enabled: true,
        is_principal: false,
        first_name: Some(input.first_name),
        last_name: Some(input.last_name),
        email: Some(input.email),
        phone_no: Some(input.phone_no),
        detail_meta: input.detail_meta,
        ..Default::default()
    };

    USERS.with(|users| {
        users.borrow_mut().insert(id, user.clone());
    });

    UserResult::User(user)
}

#[update]
pub fn update_user(id: Principal, input: UserDetailsInput) -> UserResult {
    let caller = api::caller();

    // Users can update their own profile, or admins can update any user
    if caller != id {
        let auth_result = ensure_admin(caller);
        if auth_result.is_err() {
            return UserResult::Error(ApiError::unauthorized(
                "You can only update your own user profile or must be an admin",
            ));
        }
    }

    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();

        if let Some(user) = users_mut.get(&id) {
            // Create an updated user
            let updated_user = User {
                first_name: Some(input.first_name),
                last_name: Some(input.last_name),
                phone_no: Some(input.phone_no),
                email: Some(input.email),
                detail_meta: input.detail_meta,
                updated_at: api::time(),
                updated_by: caller,
                ..user.clone()
            };

            // Insert updated user
            users_mut.insert(id, updated_user.clone());

            UserResult::User(updated_user)
        } else {
            UserResult::Error(ApiError::not_found("User not found"))
        }
    })
}

#[update]
pub fn update_user_orgs(id: Principal, org_ids: Vec<Principal>) -> UserResult {
    let caller = api::caller();

    // Only admins can modify organization associations, or users can manage their own orgs if they're admins
    if caller != id {
        let auth_result = ensure_admin(caller);
        if auth_result.is_err() {
            return UserResult::Error(ApiError::unauthorized(
                "Only administrators can update user organizations",
            ));
        }
    } else {
        // If caller is the same as target id, ensure they have admin role to modify their own orgs
        let auth_result = ensure_admin(caller);
        if auth_result.is_err() {
            return UserResult::Error(ApiError::unauthorized(
                "You need admin rights to modify organization associations",
            ));
        }
    }

    // Validate that all org IDs exist
    for org_id in &org_ids {
        let org_exists = ORGANIZATIONS.with(|orgs| orgs.borrow().get(org_id).is_some());
        if !org_exists {
            return UserResult::Error(ApiError::not_found(&format!(
                "Organization with ID {} not found",
                org_id
            )));
        }
    }

    USERS.with(|users| {
        let mut users_mut = users.borrow_mut();

        if let Some(user) = users_mut.get(&id) {
            // Create an updated user with new organization IDs
            let updated_user = User {
                org_ids: org_ids,
                updated_at: api::time(),
                updated_by: caller,
                ..user.clone()
            };

            // Insert updated user
            users_mut.insert(id, updated_user.clone());

            UserResult::User(updated_user)
        } else {
            UserResult::Error(ApiError::not_found("User not found"))
        }
    })
}

const REVIEW_REFRESH_INTERVAL: u64 = 86400; // 24 hours in seconds
const OPENAI_HOST: &str = "api.openai.com";
const GPT_MODEL: &str = "gpt-4o";
const REQUEST_CYCLES: u64 = 230_949_972_000;
const UNIQUE_CODE_EXPIRATION_SECONDS: u64 = 300; // 5 minutes
const MAX_HTTP_RETRIES: u32 = 3;
const RETRY_DELAY_SECONDS: u64 = 2;

#[update]
async fn generate_product_review_v2(product_id: Principal) -> ApiResponse<ProductResponse> {
    let product = match get_product(&product_id) {
        Ok(p) => p,
        Err(e) => return ApiResponse::error(e),
    };

    if !should_generate_new_review(&product) {
        ic_cdk::print(format!("ℹ️ Product review for {} is up-to-date. Skipping generation.", product_id));
        // Return current product data if review is fresh
        return ApiResponse::success(ProductResponse { product }); 
    }
    
    ic_cdk::print(format!("ℹ️ Generating new product review for {}.", product_id));

    // Scrape Review Summary - Handle the Result
    let review_summary_result = scrape_product_review(&product).await;
    let review_summary = match review_summary_result {
        Ok(summary) => summary,
        Err(e) => {
            ic_cdk::print(format!("⚠️ Failed to scrape review for {}: {:?}", product_id, e));
            // Return the scraping error
            return ApiResponse::error(e);
        }
    };

    // Analyze Sentiment (already returns Result, handled below)
    let sentiment_analysis_result = analyze_sentiment_with_openai(&review_summary).await;
    let sentiment_analysis = match sentiment_analysis_result {
        Ok(sentiment) => sentiment,
        Err(e) => {
            ic_cdk::print(format!("⚠️ Failed to analyze sentiment for {}: {:?}", product_id, e));
            return ApiResponse::error(e); 
        }
    };

    // Update Product with Review
    match update_product_with_review(product, sentiment_analysis) {
        Ok(updated_product) => {
            ic_cdk::print(format!("✅ Successfully generated review for product {}.", product_id));
            ApiResponse::success(ProductResponse { product: updated_product })
        }
        Err(e) => {
            ic_cdk::print(format!("❌ ERROR: Failed to update product {} with review: {:?}", product_id, e));
            ApiResponse::error(e)
        }
    }
}

fn get_product(product_id: &Principal) -> Result<Product, ApiError> {
    PRODUCTS.with(|products| {
        products
            .borrow()
            .get(product_id)
            .map(|p| p.clone())
            .ok_or_else(|| ApiError::not_found("Product not found"))
    })
}

fn should_generate_new_review(product: &Product) -> bool {
    let latest_review_time = product
        .metadata
        .iter()
        .find(|v| v.key == "latest_product_review_generation")
        .and_then(|v| v.value.parse::<u64>().ok());

    latest_review_time
        .map(|time| time < api::time() - REVIEW_REFRESH_INTERVAL)
        .unwrap_or(true)
}

async fn analyze_sentiment_with_openai(review_text: &str) -> Result<String, ApiError> {
    let request = match create_openai_request(review_text) {
        Ok(req) => req,
        Err(e) => return Err(e),
    };

    let mut attempts = 0;
    loop {
        attempts += 1;
        ic_cdk::print(format!("ℹ️ Attempt {} analyzing sentiment with OpenAI.", attempts));

        // Cast REQUEST_CYCLES to u128
        match http_request(request.clone(), REQUEST_CYCLES as u128).await {
            Ok((response,)) => {
                // Clone status for potential logging before moving its inner value
                let original_status = response.status.clone();
                // Convert Nat status to u64 for comparison
                let status_code: u64 = match response.status.0.try_into() {
                    Ok(code) => code,
                    Err(_) => {
                        // Use the cloned status for logging
                        ic_cdk::print(format!("❌ ERROR: Invalid status code received from OpenAI: {}", original_status));
                        return Err(ApiError::external_api_error("Invalid status code received"));
                    }
                };

                if status_code >= 200 && status_code < 300 {
                    let response_body = String::from_utf8(response.body).map_err(|e| {
                        ic_cdk::print(format!("❌ ERROR: Invalid UTF-8 in OpenAI response: {:?}", e));
                        ApiError::external_api_error("Invalid UTF-8 in OpenAI response")
                    })?;

                    let parsed: Value = serde_json::from_str(&response_body).map_err(|e| {
                        ic_cdk::print(format!("❌ ERROR: Invalid JSON in OpenAI response: {:?}, Body: {}", e, response_body));
                        ApiError::external_api_error("Invalid JSON response from OpenAI")
                    })?;

                    // Extract the content
                    return Ok(parsed["choices"][0]["message"]["content"]
                        .as_str()
                        .unwrap_or_default()
                        .to_string());
                } else {
                    let error_message = format!(
                        "OpenAI API returned status {}: {}",
                        status_code, // Use converted status code
                        String::from_utf8_lossy(&response.body)
                    );
                    ic_cdk::print(format!("❌ ERROR: {}", error_message));

                    // Treat server-side errors (5xx) as potentially retryable
                    if status_code >= 500 && attempts < MAX_HTTP_RETRIES {
                        ic_cdk::print(format!("⏱️ Retrying analyze_sentiment after delay..."));
                        utils::async_delay(Duration::from_secs(RETRY_DELAY_SECONDS * attempts as u64)).await;
                        continue; // Retry the loop
                    }
                    // For non-retryable errors or max retries reached
                    return Err(ApiError::external_api_error(&error_message));
                }
            }
            Err((rejection_code, message)) => {
                 let error_message = format!(
                    "HTTP request to OpenAI failed. RejectionCode: {:?}, Error: {}",
                    rejection_code, message
                );
                ic_cdk::print(format!("❌ ERROR: {}", error_message));

                 // Retry on most errors up to the limit
                if attempts < MAX_HTTP_RETRIES {
                    ic_cdk::print(format!("⏱️ Retrying analyze_sentiment after rejection delay..."));
                    utils::async_delay(Duration::from_secs(RETRY_DELAY_SECONDS * attempts as u64)).await;
                    continue; // Retry the loop
                }
                // Max retries reached
                return Err(ApiError::external_api_error(&error_message));
            }
        }
    }
}

fn create_openai_request(review_text: &str) -> Result<CanisterHttpRequestArgument, ApiError> {
    let escaped_review = review_text.replace("\"", "\\\"");
    let request_body = format!(
        r#"{{
        "model": "{GPT_MODEL}",
        "messages": [{{
            "role": "user",
            "content": "With this product review summary: {}\n Please help summarize what is the overall sentiment of the product"
        }}],
        "temperature": 0.7
    }}"#,
        escaped_review
    );

    Ok(CanisterHttpRequestArgument {
        url: format!("https://{OPENAI_HOST}/v1/chat/completions"),
        method: HttpMethod::POST,
        body: Some(request_body.into_bytes()),
        max_response_bytes: None,
        transform: Some(TransformContext {
            function: TransformFunc(candid::Func {
                principal: api::id(),
                method: "transform".to_string(),
            }),
            context: vec![],
        }),
        headers: create_request_headers(),
    })
}

fn create_request_headers() -> Vec<HttpHeader> {
    // Read StorableString from stable storage
    let api_key_storable = CONFIG_OPENAI_API_KEY.with(|cell| cell.borrow().get().clone());
    let api_key = &api_key_storable.0; // Get reference to inner String
    
    if api_key.is_empty() {
        ic_cdk::print("⚠️ WARNING: OpenAI API Key is not configured.");
        // Return headers without Authorization if key is missing
        return vec![
            HttpHeader {
                name: "Host".to_string(),
                value: format!("{OPENAI_HOST}:443"),
            },
            HttpHeader {
                name: "User-Agent".to_string(),
                value: "exchange_rate_canister".to_string(), // Consider making this configurable too
            },
            HttpHeader {
                name: "Content-Type".to_string(),
                value: "application/json".to_string(),
            },
            HttpHeader {
                name: "Idempotency-Key".to_string(),
                value: generate_unique_principal(Principal::anonymous()).to_string(),
            },
        ];
    }

    vec![
        HttpHeader {
            name: "Host".to_string(),
            value: format!("{OPENAI_HOST}:443"),
        },
        HttpHeader {
            name: "User-Agent".to_string(),
            value: "exchange_rate_canister".to_string(),
        },
        HttpHeader {
            name: "Content-Type".to_string(),
            value: "application/json".to_string(),
        },
        HttpHeader {
            name: "Authorization".to_string(),
            value: format!("Bearer {}", api_key), // Use the inner string
        },
        HttpHeader {
            name: "Idempotency-Key".to_string(),
            value: generate_unique_principal(Principal::anonymous()).to_string(),
        },
    ]
}

fn update_product_with_review(
    mut product: Product,
    review_content: String,
) -> Result<Product, ApiError> {
    let review_metadata = Metadata {
        key: "product_review".to_string(),
        value: review_content,
    };
    let timestamp_metadata = Metadata {
        key: "latest_product_review_generation".to_string(),
        value: api::time().to_string(),
    };

    product.metadata.push(review_metadata);
    product.metadata.push(timestamp_metadata);

    PRODUCTS.with(|products| {
        products.borrow_mut().insert(product.id, product.clone());
    });

    Ok(product)
}

async fn scrape_product_review(product: &Product) -> Result<String, ApiError> {
    // Read StorableString from stable storage
    let base_scraper_url_storable = CONFIG_SCRAPER_URL.with(|cell| cell.borrow().get().clone());
    let base_scraper_url = &base_scraper_url_storable.0; // Get reference to inner String

    if base_scraper_url.is_empty() {
        ic_cdk::print("⚠️ WARNING: Scraper URL is not configured.");
        return Err(ApiError::internal_error("Scraper service URL not configured"));
    }

    // Use the inner string to format the URL
    let url = format!(
        "{}/product-review?id={}",
        base_scraper_url,
        product.id.to_string()
    );

    let request = CanisterHttpRequestArgument {
        url: url.clone(), // Clone url for potential retries
        method: HttpMethod::GET,
        body: None,
        max_response_bytes: None, // Consider setting a limit
        transform: Some(TransformContext {
            function: TransformFunc(candid::Func {
                principal: api::id(),
                method: "transform".to_string(),
            }),
            context: vec![],
        }),
        headers: vec![],
    };

    let mut attempts = 0;
    loop {
        attempts += 1;
        ic_cdk::print(format!("ℹ️ Attempt {} scraping review from: {}", attempts, request.url));

        // Cast REQUEST_CYCLES to u128
        match http_request(request.clone(), REQUEST_CYCLES as u128).await {
            Ok((response,)) => {
                // Clone status for potential logging before moving its inner value
                let original_status = response.status.clone();
                // Convert Nat status to u64 for comparison
                let status_code: u64 = match response.status.0.try_into() {
                    Ok(code) => code,
                    Err(_) => {
                        // Use the cloned status for logging
                        ic_cdk::print(format!("❌ ERROR: Invalid status code received from scraper: {}", original_status));
                        return Err(ApiError::external_api_error("Invalid status code received"));
                    }
                };

                if status_code >= 200 && status_code < 300 {
                    return String::from_utf8(response.body).map_err(|e| {
                        ic_cdk::print(format!("❌ ERROR: Failed to decode scraper response body: {:?}", e));
                        ApiError::external_api_error("Failed to decode scraper response")
                    });
                } else {
                    let error_message = format!(
                        "Scraper service returned status {}: {}",
                        status_code, // Use converted status code
                        String::from_utf8_lossy(&response.body)
                    );
                    ic_cdk::print(format!("❌ ERROR: {}", error_message));

                    // Treat server-side errors (5xx) as potentially retryable
                    if status_code >= 500 && attempts < MAX_HTTP_RETRIES {
                        ic_cdk::print(format!("⏱️ Retrying scrape_product_review after delay..."));
                        utils::async_delay(Duration::from_secs(RETRY_DELAY_SECONDS * attempts as u64)).await;
                        continue; // Retry the loop
                    }
                    // For non-retryable errors or max retries reached
                    return Err(ApiError::external_api_error(&error_message));
                }
            }
            Err((rejection_code, message)) => {
                let error_message = format!(
                    "HTTP request to scraper failed. RejectionCode: {:?}, Error: {}",
                    rejection_code, message
                );
                ic_cdk::print(format!("❌ ERROR: {}", error_message));

                // Retry on specific rejection codes if desired (e.g., network errors)
                // For now, let's retry on most errors up to the limit
                if attempts < MAX_HTTP_RETRIES {
                    ic_cdk::print(format!("⏱️ Retrying scrape_product_review after rejection delay..."));
                    utils::async_delay(Duration::from_secs(RETRY_DELAY_SECONDS * attempts as u64)).await;
                    continue; // Retry the loop
                }
                // Max retries reached
                return Err(ApiError::external_api_error(&error_message));
            }
        }
    }
}

#[query]
pub fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

#[query]
fn transform(raw: TransformArgs) -> HttpResponse {
    let headers = vec![
        HttpHeader {
            name: "Content-Security-Policy".to_string(),
            value: "default-src 'self'".to_string(),
        },
        HttpHeader {
            name: "Referrer-Policy".to_string(),
            value: "strict-origin".to_string(),
        },
        HttpHeader {
            name: "Permissions-Policy".to_string(),
            value: "geolocation=(self)".to_string(),
        },
        HttpHeader {
            name: "Strict-Transport-Security".to_string(),
            value: "max-age=63072000".to_string(),
        },
        HttpHeader {
            name: "X-Frame-Options".to_string(),
            value: "DENY".to_string(),
        },
        HttpHeader {
            name: "X-Content-Type-Options".to_string(),
            value: "nosniff".to_string(),
        },
    ];

    let mut res = HttpResponse {
        status: raw.response.status.clone(),
        body: raw.response.body.clone(),
        headers,
    };

    if res.status == 200u64 {
        res.body = raw.response.body;
    } else {
        api::print(format!("Received an error: err = {:?}", raw));
    }
    res
}

#[query]
pub fn find_resellers_by_name_or_id(name: String) -> Vec<Reseller> {
    let filter = name.trim().to_lowercase();

    RESELLERS.with(|resellers| {
        resellers
            .borrow()
            .iter()
            .filter(|(_, reseller)| reseller.name.to_lowercase().contains(&filter))
            .map(|(_, reseller)| reseller.clone())
            .collect()
    })
}

#[query]
pub fn verify_reseller_v2(request: VerifyResellerRequest) -> ApiResponse<ResellerVerificationResponse> {
    let current_time = api::time();
    let reseller_id = request.reseller_id;
    let code_timestamp = request.timestamp;
    let context_str = request.context.as_deref().unwrap_or("");

    // 1. Check for expiration / replay attack
    if current_time > code_timestamp + UNIQUE_CODE_EXPIRATION_SECONDS {
        return ApiResponse::success(ResellerVerificationResponse {
            status: ResellerVerificationStatus::ExpiredCode,
            organization: None,
            reseller: None,
        });
    }
    // Basic check for future timestamps (allowing a small clock skew, e.g., 60 seconds)
    if code_timestamp > current_time + 60 {
         return ApiResponse::success(ResellerVerificationResponse {
            status: ResellerVerificationStatus::InvalidCode, // Or a more specific error
            organization: None,
            reseller: None,
        });
    }

    // 2. Find Reseller
    let reseller_opt = RESELLERS.with(|r| r.borrow().get(&reseller_id).clone());
    if reseller_opt.is_none() {
        return ApiResponse::success(ResellerVerificationResponse {
            status: ResellerVerificationStatus::ResellerNotFound,
            organization: None,
            reseller: None,
        });
    }
    let reseller = reseller_opt.unwrap();

    // 3. Find Organization
    let org_opt = ORGANIZATIONS.with(|o| o.borrow().get(&reseller.org_id).clone());
    if org_opt.is_none() {
         return ApiResponse::success(ResellerVerificationResponse {
            status: ResellerVerificationStatus::OrganizationNotFound,
            organization: None,
            reseller: Some(reseller), // Can still return reseller info
        });
    }
    let organization = org_opt.unwrap();

    // 4. Get Reseller's Public Key
    // Note: In the previous implementation, reseller had its own public key.
    // Let's assume the verification should use the ORGANIZATION's public key, 
    // derived from the private key used in generation.
    // If reseller should have its own keypair, the model and generation logic need adjustment.
    let public_key_bytes = match hex::decode(&organization.private_key) { // Using org's key for verification
        Ok(bytes) => bytes,
        Err(_) => {
             return ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InternalError,
                organization: Some(OrganizationPublic::from(organization.clone())), 
                reseller: Some(reseller),
            });
        }
    };
    let public_key_encoded_point = match EncodedPoint::from_bytes(public_key_bytes) {
        Ok(point) => point,
        Err(_) => {
             return ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InternalError,
                organization: Some(OrganizationPublic::from(organization.clone())), 
                reseller: Some(reseller),
            });
        }
    };
    let public_key = match VerifyingKey::from_encoded_point(&public_key_encoded_point) {
        Ok(key) => key,
        Err(_) => {
             return ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InternalError,
                organization: Some(OrganizationPublic::from(organization.clone())), 
                reseller: Some(reseller),
            });
        }
    };

    // 5. Prepare message hash
    let msg = format!("{}_{}_{}", reseller_id.to_string(), code_timestamp, context_str);
    let mut hasher = Sha256::new();
    hasher.update(msg);
    let hashed_message = hasher.finalize();

    // 6. Decode signature
    let decoded_code = match hex::decode(&request.unique_code) {
        Ok(bytes) => bytes,
        Err(_) => {
             return ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InvalidCode,
                organization: Some(OrganizationPublic::from(organization.clone())), 
                reseller: Some(reseller),
            });
        }
    };
    let signature = match Signature::from_slice(decoded_code.as_slice()) {
         Ok(sig) => sig,
         Err(_) => {
             return ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InvalidCode,
                organization: Some(OrganizationPublic::from(organization.clone())), 
                reseller: Some(reseller),
            });
         }
     };

    // 7. Verify signature
    match public_key.verify(&hashed_message, &signature) {
        Ok(_) => {
            ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::Success,
                organization: Some(OrganizationPublic::from(organization)),
                reseller: Some(reseller),
            })
        }
        Err(_) => {
            ApiResponse::success(ResellerVerificationResponse {
                status: ResellerVerificationStatus::InvalidCode,
                organization: Some(OrganizationPublic::from(organization)), // Still return org/reseller info on failure
                reseller: Some(reseller),
            })
        }
    }
}

#[update]
pub fn generate_reseller_unique_code_v2(request: GenerateResellerUniqueCodeRequest) -> ApiResponse<ResellerUniqueCodeResponse> {
    let reseller_id = request.reseller_id;
    let context_str = request.context.as_deref().unwrap_or(""); // Use empty string if None

    // Check if a reseller exists
    let mut reseller_found = false;
    let mut reseller_org_id = Principal::anonymous();

    RESELLERS.with(|resellers| {
        if let Some(reseller) = resellers.borrow().get(&reseller_id) {
            reseller_found = true;
            reseller_org_id = reseller.org_id;
        }
    });

    if !reseller_found {
        return ApiResponse::error(ApiError::not_found(&format!(
            "Reseller with ID {} not found",
            reseller_id
        )));
    }

    // Check if an organization exists
    let mut org_found = false;
    let mut org_private_key = String::new();

    ORGANIZATIONS.with(|orgs| {
        if let Some(org) = orgs.borrow().get(&reseller_org_id) {
            org_found = true;
            org_private_key = org.private_key.clone();
        }
    });

    if !org_found {
        return ApiResponse::error(ApiError::not_found(&format!(
            "Organization with ID {} not found for reseller {}",
            reseller_org_id,
            reseller_id
        )));
    }

    // Deserialize private key
    let private_key_bytes = match hex::decode(&org_private_key) {
        Ok(bytes) => bytes,
        Err(_) => {
            return ApiResponse::error(ApiError::internal_error(
                "Malformed secret key for organization",
            ))
        }
    };

    let private_key = match SigningKey::from_slice(&private_key_bytes.as_slice()) {
        Ok(key) => key,
        Err(_) => {
            return ApiResponse::error(ApiError::internal_error(
                "Malformed secret key for organization",
            ))
        }
    };

    // Create message including reseller ID, current timestamp, and context
    let current_time = api::time();
    let msg = format!("{}_{}_{}", reseller_id.to_string(), current_time, context_str);
    
    // Hash and sign
    let mut hasher = Sha256::new();
    hasher.update(msg);
    let hashed_message = hasher.finalize();

    let signature: Signature = private_key.sign(&hashed_message);
    let signature_hex = hex::encode(signature.to_bytes());

    ApiResponse::success(ResellerUniqueCodeResponse {
        unique_code: signature_hex,
        reseller_id,
        timestamp: current_time,
        context: request.context, // Return the original context if provided
    })
}

#[query]
pub fn list_product_serial_numbers(
    organization_id: Option<Principal>,
    product_id: Option<Principal>,
) -> Result<Vec<ProductSerialNumber>, ApiError> {
    match (organization_id, product_id) {
        (None, _) => fetch_all_serial_numbers(),
        (Some(org_id), None) => fetch_organization_serial_numbers(org_id),
        (Some(org_id), Some(p_id)) => fetch_product_serial_numbers(org_id, p_id),
    }
}

fn fetch_all_serial_numbers() -> Result<Vec<ProductSerialNumber>, ApiError> {
    let mut serial_numbers = Vec::new();

    PRODUCT_SERIAL_NUMBERS.with(|sn_store| {
        sn_store.borrow().iter().for_each(|(_, serialized_sn)| {
            let decoded_numbers = decode_product_serial_numbers(&serialized_sn);
            serial_numbers.extend(decoded_numbers);
        });
    });

    Ok(serial_numbers)
}

fn fetch_organization_serial_numbers(
    org_id: Principal,
) -> Result<Vec<ProductSerialNumber>, ApiError> {
    let product_ids = get_organization_product_ids(org_id);
    let mut serial_numbers = Vec::new();

    PRODUCT_SERIAL_NUMBERS.with(|sn_store| {
        let store = sn_store.borrow();
        for product_id in product_ids {
            if let Some(serialized_sn) = store.get(&product_id) {
                let decoded_numbers = decode_product_serial_numbers(&serialized_sn);
                serial_numbers.extend(decoded_numbers);
            }
        }
    });

    Ok(serial_numbers)
}

fn fetch_product_serial_numbers(
    org_id: Principal,
    product_id: Principal,
) -> Result<Vec<ProductSerialNumber>, ApiError> {
    if !is_product_owned_by_organization(product_id, org_id) {
        return Ok(Vec::new());
    }

    let serial_numbers = PRODUCT_SERIAL_NUMBERS.with(|sn_store| {
        sn_store
            .borrow()
            .get(&product_id)
            .map_or(Vec::new(), |serialized_sn| {
                decode_product_serial_numbers(&serialized_sn)
            })
    });

    Ok(serial_numbers)
}

fn get_organization_product_ids(org_id: Principal) -> Vec<Principal> {
    let mut product_ids = Vec::new();

    PRODUCTS.with(|products| {
        products
            .borrow()
            .iter()
            .filter(|(_, product)| product.org_id == org_id)
            .for_each(|(id, _)| product_ids.push(id));
    });

    product_ids
}

fn is_product_owned_by_organization(product_id: Principal, org_id: Principal) -> bool {
    PRODUCTS.with(|products| {
        products
            .borrow()
            .get(&product_id)
            .map_or(false, |product| product.org_id == org_id)
    })
}

#[update]
pub fn create_product_serial_number(
    product_id: Principal,
    user_serial_no: Option<String>,
) -> ProductSerialNumberResult {
    // Check if the product exists
    let product_opt = PRODUCTS.with(|products| products.borrow().get(&product_id));

    if product_opt.is_none() {
        return ProductSerialNumberResult::Error(ApiError::not_found(&format!(
            "Product with ID {} not found",
            product_id
        )));
    }

    let product = product_opt.unwrap();

    // Check for write product permission
    let authorization_result =
        authorize_for_organization(api::caller(), product.org_id, Permission::WriteProduct);
    if authorization_result.is_err() {
        return ProductSerialNumberResult::Error(authorization_result.err().unwrap());
    }

    // Continue with existing logic
    let serial_no = generate_unique_principal(Principal::anonymous());
    let user_serial = user_serial_no.unwrap_or_else(|| serial_no.to_string());

    let product_serial_number = ProductSerialNumber {
        product_id,
        serial_no,
        user_serial_no: user_serial,
        print_version: 0,
        metadata: vec![],
        created_at: api::time(),
        created_by: api::caller(),
        updated_at: api::time(),
        updated_by: api::caller(),
    };

    PRODUCT_SERIAL_NUMBERS.with(|serial_numbers| {
        let mut serial_numbers_mut = serial_numbers.borrow_mut();

        // Get existing serial numbers for this product, if any
        let current_entries = match serial_numbers_mut.get(&product_id) {
            Some(serialized_sn_vec) => decode_product_serial_numbers(&serialized_sn_vec),
            None => Vec::new(),
        };

        // Create a new collection with existing items plus the new one
        let mut updated_entries = current_entries;
        updated_entries.push(product_serial_number.clone());

        // Serialize and store the updated collection
        let serialized_entries = encode_product_serial_numbers(&updated_entries);
        serial_numbers_mut.insert(product_id, serialized_entries);
    });

    ProductSerialNumberResult::Result(product_serial_number)
}

#[update]
pub fn update_product_serial_number(
    product_id: Principal,
    serial_no: Principal,
    user_serial_no: Option<String>,
) -> ProductSerialNumberResult {
    PRODUCT_SERIAL_NUMBERS.with(|serial_numbers| {
        let mut serial_numbers_mut = serial_numbers.borrow_mut();

        // Check if the product exists
        if let Some(serialized_sn_vec) = serial_numbers_mut.get(&product_id) {
            // Decode the collection
            let mut product_sn_vec = decode_product_serial_numbers(&serialized_sn_vec);

            // Check for duplicate user_serial_no
            if let Some(sn) = &user_serial_no {
                let has_duplicate = product_sn_vec
                    .iter()
                    .any(|p_sn| p_sn.user_serial_no == *sn && p_sn.serial_no != serial_no);

                if has_duplicate {
                    return ProductSerialNumberResult::Error(ApiError::already_exists(
                        "Existing user serial number already exists",
                    ));
                }
            }

            // Find the serial number to update
            let sn_index = product_sn_vec.iter().position(|s| s.serial_no == serial_no);

            if let Some(idx) = sn_index {
                // Update the serial number
                let mut updated_sn = product_sn_vec[idx].clone();
                updated_sn.user_serial_no = user_serial_no.unwrap_or_default();
                updated_sn.updated_at = api::time();
                updated_sn.updated_by = api::caller();

                // Update in a collection
                product_sn_vec[idx] = updated_sn.clone();

                // Save an updated collection
                serial_numbers_mut
                    .insert(product_id, encode_product_serial_numbers(&product_sn_vec));

                ProductSerialNumberResult::Result(updated_sn)
            } else {
                ProductSerialNumberResult::Error(ApiError::not_found("Serial number not found"))
            }
        } else {
            ProductSerialNumberResult::Error(ApiError::not_found(
                "Product has no registered serial_nos",
            ))
        }
    })
}

#[update]
pub fn print_product_serial_number(
    product_id: Principal,
    serial_no: Principal,
) -> ProductUniqueCodeResult {
    // Access product serial numbers and product information from stable storage
    PRODUCT_SERIAL_NUMBERS.with(|serial_numbers| {
        let mut serial_numbers_mut = serial_numbers.borrow_mut();

        // Check if the product has any serial numbers
        if let Some(serialized_sn_vec) = serial_numbers_mut.get(&product_id) {
            let mut product_sn_vec = decode_product_serial_numbers(&serialized_sn_vec);

            // Find the specific serial number
            let sn_index = product_sn_vec
                .iter()
                .position(|sn| sn.serial_no == serial_no);
            if sn_index.is_none() {
                return ProductUniqueCodeResult::Error(ApiError::not_found(
                    "Serial number for product is not present",
                ));
            }

            // Get product information
            let mut product_opt = None;
            PRODUCTS.with(|products| {
                let products_ref = products.borrow();
                match products_ref.get(&product_id) {
                    Some(product) => product_opt = Some(product.clone()),
                    None => product_opt = None,
                }
            });

            if product_opt.is_none() {
                return ProductUniqueCodeResult::Error(ApiError::not_found(
                    "Product reference does not exist",
                ));
            }

            let product = product_opt.unwrap();

            // Get organization information
            let mut organization_opt = None;
            ORGANIZATIONS.with(|orgs| {
                let orgs_ref = orgs.borrow();
                match orgs_ref.get(&product.org_id) {
                    Some(org) => organization_opt = Some(org.clone()),
                    None => organization_opt = None,
                }
            });

            if organization_opt.is_none() {
                return ProductUniqueCodeResult::Error(ApiError::not_found(
                    "Organization does not exist",
                ));
            }

            let organization = organization_opt.unwrap();

            // Deserialize private key
            let private_key_bytes = match hex::decode(&organization.private_key) {
                Ok(bytes) => bytes,
                Err(_) => {
                    return ProductUniqueCodeResult::Error(ApiError::internal_error(
                        "Malformed secret key for organization",
                    ))
                }
            };

            let private_key = match SigningKey::from_slice(&private_key_bytes.as_slice()) {
                Ok(key) => key,
                Err(_) => {
                    return ProductUniqueCodeResult::Error(ApiError::internal_error(
                        "Malformed secret key for organization",
                    ))
                }
            };

            // Update the serial number's print version
            let sn_idx = sn_index.unwrap();
            product_sn_vec[sn_idx].print_version += 1;
            product_sn_vec[sn_idx].updated_at = api::time();
            product_sn_vec[sn_idx].updated_by = api::caller();

            let updated_sn = product_sn_vec[sn_idx].clone();

            // Save an updated serial number collection
            serial_numbers_mut.insert(product_id, encode_product_serial_numbers(&product_sn_vec));

            // Create unique code by signing a message
            let msg = format!(
                "{}_{}_{}",
                product_id.to_string(),
                serial_no.to_string(),
                updated_sn.print_version
            );
            let mut hasher = Sha256::new();
            hasher.update(msg);
            let hashed_message = hasher.finalize();

            let signature: Signature = private_key.sign(&hashed_message);

            ProductUniqueCodeResult::Result(ProductUniqueCodeResultRecord {
                unique_code: signature.to_string(),
                print_version: updated_sn.print_version,
                product_id: updated_sn.product_id,
                serial_no: updated_sn.serial_no,
                created_at: updated_sn.updated_at,
            })
        } else {
            ProductUniqueCodeResult::Error(ApiError::not_found(
                "Product has no serial number recorded",
            ))
        }
    })
}

#[update]
pub fn verify_product_v2(request: VerifyProductEnhancedRequest) -> ApiResponse<ProductVerificationEnhancedResponse> {
    let caller = api::caller();
    
    // Check for rate limiting
    let rate_limit_result = rate_limiter::record_verification_attempt(caller, request.product_id);
    if let Err(error) = rate_limit_result {
        return ApiResponse::error(error);
    }
    
    // Check if the product exists
    let product_opt = PRODUCTS.with(|products| products.borrow().get(&request.product_id).map(|p| p.clone()));
    
    if product_opt.is_none() {
        return ApiResponse::error(ApiError::not_found("Product is invalid"));
    }
    
    let product = product_opt.unwrap();

    // Check for serial number
    let mut has_serial_numbers = false;
    let mut product_sn_opt = None;

    PRODUCT_SERIAL_NUMBERS.with(|serial_numbers| {
        if let Some(serialized_sn_vec) = serial_numbers.borrow().get(&request.product_id) {
            has_serial_numbers = true;
            let product_sn_vec = decode_product_serial_numbers(&serialized_sn_vec);
            product_sn_opt = product_sn_vec
                .iter()
                .find(|p_sn| p_sn.serial_no == request.serial_no)
                .cloned();
        }
    });

    if !has_serial_numbers {
        return ApiResponse::error(ApiError::not_found("Product has no serial numbers registered"));
    }

    if product_sn_opt.is_none() {
        return ApiResponse::error(ApiError::not_found("Serial number not found for this product"));
    }

    let product_sn = product_sn_opt.unwrap();

    // Check if the print version is correct/current
    if product_sn.print_version != request.print_version {
        return ApiResponse::error(ApiError::invalid_input("Unique code expired"));
    }
    
    // Replay attack prevention - check timestamp if provided
    if let Some(client_timestamp) = request.timestamp {
        let current_time = api::time();
        let time_diff = if current_time > client_timestamp {
            current_time - client_timestamp
        } else {
            client_timestamp - current_time
        };
        
        // If timestamp is more than 5 minutes off, reject as potential replay attack
        if time_diff > 300 {  // 5 minutes in seconds
            return ApiResponse::error(ApiError::invalid_input("Request timestamp too old or future dated"));
        }
    }

    // Deserialize public key
    let public_key_bytes = match hex::decode(&product.public_key) {
        Ok(bytes) => bytes,
        Err(_) => {
            return ApiResponse::error(ApiError::internal_error("Malformed public key"));
        }
    };

    let public_key_encoded_point = match EncodedPoint::from_bytes(public_key_bytes) {
        Ok(point) => point,
        Err(_) => {
            return ApiResponse::error(ApiError::internal_error("Malformed public key"));
        }
    };

    let public_key = match VerifyingKey::from_encoded_point(&public_key_encoded_point) {
        Ok(key) => key,
        Err(_) => {
            return ApiResponse::error(ApiError::internal_error("Malformed public key"));
        }
    };

    // Create message to verify, including nonce if provided
    let nonce_suffix = request.nonce.as_deref().unwrap_or("");
    let msg = format!(
        "{}_{}_{}_{}",
        request.product_id.to_string(),
        request.serial_no.to_string(),
        request.print_version,
        nonce_suffix
    );
    
    let mut hasher = Sha256::new();
    hasher.update(msg);
    let hashed_message = hasher.finalize();

    let decoded_code = match hex::decode(&request.unique_code) {
        Ok(bytes) => bytes,
        Err(_) => {
            return ApiResponse::error(ApiError::invalid_input("Malformed unique code"));
        }
    };
    
    let signature = match Signature::from_slice(decoded_code.as_slice()) {
        Ok(sig) => sig,
        Err(_) => {
            return ApiResponse::error(ApiError::invalid_input("Invalid signature format"));
        }
    };
    
    // Verify the signature
    let verify_result = public_key.verify(&hashed_message, &signature);
    
    if verify_result.is_err() {
        let response = ProductVerificationEnhancedResponse {
            status: ProductVerificationStatus::Invalid,
            verification: None,
            rewards: None,
            expiration: None,
        };
        return ApiResponse::success(response);
    }
    
    // Determine if this is first verification for the product
    let verification_status = if rewards::is_first_verification_for_user(caller, request.product_id) {
        ProductVerificationStatus::FirstVerification
    } else {
        ProductVerificationStatus::MultipleVerification
    };
    
    // Calculate rewards
    let rewards_result = rewards::calculate_verification_rewards(
        caller, 
        request.product_id, 
        &verification_status
    );
    
    // Record the verification in stable storage
    let verification_id = generate_unique_principal(Principal::anonymous());
    
    let verification = ProductVerification {
        id: verification_id,
        product_id: request.product_id,
        serial_no: request.serial_no,
        print_version: request.print_version,
        metadata: request.metadata.clone(),
        created_at: api::time(),
        created_by: caller,
        status: verification_status.clone(),
    };
    
    PRODUCT_VERIFICATIONS.with(|verifications| {
        let mut verifications_mut = verifications.borrow_mut();
        
        // Get or create collection for this product
        let mut verification_vec = if let Some(serialized_verifications) = verifications_mut.get(&request.product_id) {
            decode_product_verifications(&serialized_verifications)
        } else {
            Vec::new()
        };
        
        // Add new verification
        verification_vec.push(verification.clone());
        
        // Save updated collection
        verifications_mut.insert(request.product_id, encode_product_verifications(&verification_vec));
    });
    
    // Record successful verification in rate limiter
    rate_limiter::record_successful_verification(caller, request.product_id);
    
    // Calculate expiration time (24 hours from now)
    let expiration_time = api::time() + 86400;
    
    let response = ProductVerificationEnhancedResponse {
        status: verification_status,
        verification: Some(verification),
        rewards: Some(rewards_result),
        expiration: Some(expiration_time),
    };
    
    ApiResponse::success(response)
}

#[query]
pub fn get_verification_rate_limit(product_id: Principal) -> ApiResponse<RateLimitInfo> {
    let caller = api::caller();
    
    match rate_limiter::check_rate_limit(caller, product_id) {
        Ok(rate_limit_info) => ApiResponse::success(rate_limit_info),
        Err(error) => ApiResponse::error(error),
    }
}

#[update]
pub fn list_organizations_v2(request: FindOrganizationsRequest) -> ApiResponse<OrganizationsListResponse> {
    let filter = request.name.trim().to_lowercase();
    let caller = api::caller();

    // Get user to check role and permissions
    let user_opt = USERS.with(|users| users.borrow().get(&caller));

    // Check if user exists
    if user_opt.is_none() {
        return ApiResponse::error(ApiError::unauthorized("User not found"));
    }

    let user = user_opt.unwrap();

    // Check if user has a role
    if user.user_role.is_none() {
        return ApiResponse::error(ApiError::unauthorized("User has no role assigned"));
    }

    let role = user.user_role.unwrap();

    ORGANIZATIONS.with(|orgs| {
        let orgs_borrow = orgs.borrow();
        
        // Filter organizations based on name and user's permissions
        let filtered_orgs: Vec<OrganizationPublic> = if matches!(role, UserRole::Admin) {
            // Admin can see all organizations matching the filter
            orgs_borrow
                .iter()
                .filter(|(_, org)| org.name.to_lowercase().contains(&filter))
                .map(|(_, org)| OrganizationPublic::from(org.clone()))
                .collect()
        } else {
            // Non-admin users can only see organizations they belong to
            orgs_borrow
                .iter()
                .filter(|(org_id, org)| {
                    org.name.to_lowercase().contains(&filter) && user.org_ids.contains(org_id)
                })
                .map(|(_, org)| OrganizationPublic::from(org.clone()))
                .collect()
        };
        
        // Apply pagination if requested
        let pagination_request = request.pagination.unwrap_or_default();
        let (paginated_orgs, pagination) = paginate(filtered_orgs, &pagination_request);
        
        // Create the response
        let response = OrganizationsListResponse {
            organizations: paginated_orgs,
            pagination: Some(pagination),
        };
        
        ApiResponse::success(response)
    })
}

#[update]
pub fn create_organization_v2(request: CreateOrganizationRequest) -> ApiResponse<OrganizationResponse> {
    // Input validation
    if request.name.trim().is_empty() {
        return ApiResponse::error(ApiError::invalid_input("Organization name cannot be empty"));
    }

    // For creation, we don't need to check existing permissions since this creates a brand new org
    // However, we should check if the user has a registered account at minimum
    let caller = api::caller();
    let user_exists = USERS.with(|users| users.borrow().get(&caller).is_some());

    if !user_exists {
        // Register the user automatically
        let register_result = register();
        if register_result.id == Principal::anonymous() {
            return ApiResponse::error(ApiError::internal_error("Failed to register user automatically"));
        }
    }

    let id = generate_unique_principal(Principal::anonymous()); // Generate a unique ID for the organization
    
    // Generate ECDSA keys for demonstration
    let mut rng = StdRng::from_entropy();
    let signing_key = SigningKey::random(&mut rng);
    
    let organization = Organization {
        id,
        name: request.name,
        private_key: hex::encode(&signing_key.to_bytes()),
        description: request.description,
        metadata: request.metadata,
        created_at: api::time(),
        created_by: caller,
        updated_at: api::time(),
        updated_by: caller,
    };

    ORGANIZATIONS.with(|orgs| {
        orgs.borrow_mut().insert(id, organization.clone());
    });

    // Add the organization to the user's organizations
    let add_org_to_user_result = USERS.with(|users| {
        let mut users_mut = users.borrow_mut();
        match users_mut.get(&caller) {
            Some(user) => {
                let mut updated_user = user.clone();
                updated_user.org_ids.push(id);
                updated_user.updated_at = api::time();
                users_mut.insert(caller, updated_user);
                true
            }
            None => false,
        }
    });

    if !add_org_to_user_result {
        // This is unlikely but handle it anyway
        return ApiResponse::error(ApiError::internal_error("Failed to add organization to user"));
    }

    ApiResponse::success(OrganizationResponse {
        organization: OrganizationPublic::from(organization),
    })
}

#[update]
pub fn update_organization_v2(request: UpdateOrganizationRequest) -> ApiResponse<OrganizationResponse> {
    // Input validation
    if request.name.trim().is_empty() {
        return ApiResponse::error(ApiError::invalid_input("Organization name cannot be empty"));
    }

    // Check that user has write permission for this organization
    let result = authorize_for_organization(ic_cdk::caller(), request.id, Permission::WriteOrganization);
    if result.is_err() {
        return ApiResponse::error(result.err().unwrap());
    }

    ORGANIZATIONS.with(|orgs| {
        let mut orgs_mut = orgs.borrow_mut();
        match orgs_mut.get(&request.id) {
            Some(org) => {
                // Create a new organization with updated fields
                let updated_org = Organization {
                    name: request.name,
                    description: request.description,
                    metadata: request.metadata,
                    updated_at: api::time(),
                    updated_by: api::caller(),
                    ..org.clone()
                };

                // Insert the updated organization
                orgs_mut.insert(request.id, updated_org.clone());

                ApiResponse::success(OrganizationResponse {
                    organization: OrganizationPublic::from(updated_org),
                })
            }
            None => ApiResponse::error(ApiError::not_found(&format!(
                "Organization with ID {} not found",
                request.id
            ))),
        }
    })
}

// ===== Configuration Endpoints (Admin Only) =====

#[update]
pub fn set_openai_api_key(key: String) -> ApiResponse<()> {
    // Ensure caller is admin
    if let Err(e) = ensure_admin(api::caller()) {
        return ApiResponse::error(e);
    }
    
    if key.trim().is_empty() {
        return ApiResponse::error(ApiError::invalid_input("OpenAI API key cannot be empty"));
    }

    // Wrap the String in StorableString before setting
    match CONFIG_OPENAI_API_KEY.with(|cell| cell.borrow_mut().set(StorableString(key))) {
        Ok(_) => ApiResponse::success(()),
        Err(e) => {
            ic_cdk::print(format!("❌ ERROR: Failed to set OpenAI API Key: {:?}", e));
            ApiResponse::error(ApiError::internal_error("Failed to update configuration"))
        }
    }
}

#[query]
pub fn get_openai_api_key() -> ApiResponse<String> {
    // Ensure caller is admin
    if let Err(e) = ensure_admin(api::caller()) {
        return ApiResponse::error(e);
    }

    // Get the StorableString, access the inner String with .0, then clone it
    let storable_string = CONFIG_OPENAI_API_KEY.with(|cell| cell.borrow().get().clone());
    ApiResponse::success(storable_string.0) // Return the inner String
}

#[update]
pub fn set_scraper_url(url: String) -> ApiResponse<()> {
    // Ensure caller is admin
    if let Err(e) = ensure_admin(api::caller()) {
        return ApiResponse::error(e);
    }
    
    if url.trim().is_empty() {
        return ApiResponse::error(ApiError::invalid_input("Scraper URL cannot be empty"));
    }
    // Basic URL validation might be added here (e.g., check for http/https)

    // Wrap the String in StorableString before setting
    match CONFIG_SCRAPER_URL.with(|cell| cell.borrow_mut().set(StorableString(url))) {
        Ok(_) => ApiResponse::success(()),
        Err(e) => {
            ic_cdk::print(format!("❌ ERROR: Failed to set Scraper URL: {:?}", e));
            ApiResponse::error(ApiError::internal_error("Failed to update configuration"))
        }
    }
}

#[query]
pub fn get_scraper_url() -> ApiResponse<String> {
    // Ensure caller is admin
    if let Err(e) = ensure_admin(api::caller()) {
        return ApiResponse::error(e);
    }

    // Get the StorableString, access the inner String with .0, then clone it
    let storable_string = CONFIG_SCRAPER_URL.with(|cell| cell.borrow().get().clone());
    ApiResponse::success(storable_string.0) // Return the inner String
}
</file>

<file path="src/backend/backend.did">
type Metadata = record {
    key: text;
    value: text;
};

type Organization = record {
    id: principal;
    name: text;
    description: text;
    metadata: vec Metadata;
    private_key: text;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type OrganizationPublic = record {
    id: principal;
    name: text;
    description: text;
    metadata: vec Metadata;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type OrganizationInput = record {
    name: text;
    description: text;
    metadata: vec Metadata;
};

type OrganizationResult = variant {
    organization: Organization;
    error: ApiError;
};

type Product = record {
    id: principal;
    name: text;
    org_id: principal;
    category: text;
    description: text;
    metadata: vec Metadata;
    public_key: text;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type ProductInput = record {
    name: text;
    org_id: principal;
    category: text;
    description: text;
    metadata: vec Metadata;
};

type ProductResult = variant {
    none: null;
    product: Product;
    error: ApiError;
};

type ProductSerialNumber = record {
    product_id: principal;
    serial_no: principal;
    user_serial_no: text;
    print_version: nat8;
    metadata: vec Metadata;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type ProductVerification = record {
    id: principal;
    product_id: principal;
    serial_no: principal;
    print_version: nat8;
    metadata: vec Metadata;
    created_at: nat64;
    created_by: principal;
};

type User = record {
    id: principal;
    is_principal: bool;
    is_enabled: bool;
    user_role: opt UserRole;
    org_ids: vec principal;
    first_name: opt text;
    last_name: opt text;
    phone_no: opt text;
    email: opt text;
    detail_meta: vec Metadata;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type UserDetailsInput = record {
    first_name: text;
    last_name: text;
    phone_no: text;
    email: text;
    detail_meta: vec Metadata;
};

type ErrorDetails = record {
    message: text;
    details: vec Metadata;
};

type ApiError = variant {
    NotFound: record { details: ErrorDetails };
    Unauthorized: record { details: ErrorDetails };
    InvalidInput: record { details: ErrorDetails };
    InternalError: record { details: ErrorDetails };
    AlreadyExists: record { details: ErrorDetails };
    MalformedData: record { details: ErrorDetails };
    ExternalApiError: record { details: ErrorDetails };
};

type UserResult = variant {
    none: null;
    user: User;
    error: ApiError;
};

type UserRole = variant {
    Admin;
    Reseller;
    BrandOwner;
};

type Reseller = record {
    id: principal;
    org_id: principal;
    reseller_id: text;
    name: text;
    date_joined: nat64;
    metadata: vec Metadata;
    ecommerce_urls: vec Metadata;
    created_at: nat64;
    created_by: principal;
    updated_at: nat64;
    updated_by: principal;
};

type ResellerInput = record {
    org_id: principal;
    name: text;
    metadata: vec Metadata;
    ecommerce_urls: vec Metadata;
};

type ProductSerialNumberResult = variant {
    result: ProductSerialNumber;
    error: ApiError;
};

type UniqueCodeResult = variant {
    unique_code: text;
    error: ApiError;
};

type ProductVerificationStatus = variant {
    FirstVerification;
    MultipleVerification;
    Invalid;
};

type ProductVerificationResult = variant {
    status: ProductVerificationStatus;
    error: ApiError;
};

type PrivateKeyResult = variant {
    key: text;
    error: ApiError;
};

type VerificationStatus = variant {
    Success;
    Invalid;
};

type ResellerVerificationResultRecord = record {
    status: VerificationStatus;
    organization: OrganizationPublic;
    registered_at: opt nat64;
};

type ResellerVerificationResult = variant {
    result: ResellerVerificationResultRecord;
    error: ApiError;
};

type ProductUniqueCodeResultRecord = record {
    unique_code: text;
    print_version: nat8;
    product_id: principal;
    serial_no: principal;
    created_at: nat64;
};

type ProductUniqueCodeResult = variant {
    result: ProductUniqueCodeResultRecord;
    error: ApiError;
};

// New API structures
type ResponseMetadata = record {
    timestamp: nat64;
    version: text;
    request_id: opt text;
};

type PaginationRequest = record {
    page: opt nat32;
    limit: opt nat32;
};

type PaginationResponse = record {
    page: nat32;
    limit: nat32;
    total: nat64;
    has_more: bool;
};

type UserResponse = record {
    user: User;
};

type ApiResponse_OrganizationResponse = record {
    data: opt OrganizationResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_OrganizationsListResponse = record {
    data: opt OrganizationsListResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_ProductVerificationEnhancedResponse = record {
    data: opt ProductVerificationEnhancedResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_RateLimitInfo = record {
    data: opt RateLimitInfo;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_ResellerUniqueCodeResponse = record {
    data: opt ResellerUniqueCodeResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_ResellerVerificationResponse = record {
    data: opt ResellerVerificationResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_UserResponse = record {
    data: opt UserResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_Unit = record {
    data: opt null;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_Text = record {
    data: opt text;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

type ApiResponse_ProductResponse = record {
    data: opt ProductResponse;
    error: opt ApiError;
    metadata: ResponseMetadata;
};

// Organization API structures
type CreateOrganizationRequest = record {
    name: text;
    description: text;
    metadata: vec Metadata;
};

type OrganizationResponse = record {
    organization: OrganizationPublic;
};

type UpdateOrganizationRequest = record {
    id: principal;
    name: text;
    description: text;
    metadata: vec Metadata;
};

type FindOrganizationsRequest = record {
    name: text;
    pagination: opt PaginationRequest;
};

type OrganizationsListResponse = record {
    organizations: vec OrganizationPublic;
    pagination: opt PaginationResponse;
};

// Product Verification Enhanced API Structures
type VerifyProductEnhancedRequest = record {
    product_id: principal;
    serial_no: principal;
    print_version: nat8;
    unique_code: text;
    metadata: vec Metadata;
    timestamp: opt nat64;
    nonce: opt text;
};

type VerificationRewards = record {
    points: nat32;
    is_first_verification: bool;
    special_reward: opt text;
    reward_description: opt text;
};

type ProductVerificationEnhancedResponse = record {
    status: ProductVerificationStatus;
    verification: opt ProductVerification;
    rewards: opt VerificationRewards;
    expiration: opt nat64;
};

type RateLimitInfo = record {
    remaining_attempts: nat32;
    reset_time: nat64;
    current_window_start: nat64;
};

// Reseller API v2 Structures
type GenerateResellerUniqueCodeRequest = record {
    reseller_id: principal;
    context: opt text;
};

type ResellerUniqueCodeResponse = record {
    unique_code: text;
    reseller_id: principal;
    timestamp: nat64;
    context: opt text;
};

type VerifyResellerRequestV2 = record {
    reseller_id: principal;
    unique_code: text;
    timestamp: nat64;
    context: opt text;
};

type ResellerVerificationStatus = variant {
    Success;
    InvalidCode;
    ExpiredCode;
    ReplayAttackDetected;
    ResellerNotFound;
    OrganizationNotFound;
    InternalError;
};

type ResellerVerificationResponse = record {
    status: ResellerVerificationStatus;
    organization: opt OrganizationPublic;
    reseller: opt Reseller;
};

type ProductResponse = record {
    product: Product;
};

service : {
    "get_organization_by_id": (id: principal) -> (OrganizationPublic) query;
    "create_organization": (input: OrganizationInput) -> (OrganizationPublic);
    "update_organization": (id: principal, input: OrganizationInput) -> (OrganizationPublic);
    "get_organization_private_key": (id: principal) -> (PrivateKeyResult) query;
    "find_organizations_by_name": (text) -> (vec OrganizationPublic) query;
    "create_product": (input: ProductInput) -> (ProductResult);
    "list_products": (organization_id: principal) -> (vec Product) query;
    "get_product_by_id": (id: principal) -> (ProductResult) query;
    "update_product": (id: principal, input: ProductInput) -> (Product);
    "register": () -> (User);
    "set_self_role": (role_id: UserRole) -> (UserResult);
    "register_as_reseller": (ResellerInput) -> (UserResult);
    "register_as_organization": (OrganizationInput) -> (UserResult);
    "get_user_by_id": (id: principal) -> (opt User) query;
    "whoami": () -> (opt User) query;
    "update_self_details": (input: UserDetailsInput) -> (UserResult);
    "create_user": (id: principal, input: UserDetailsInput) -> (UserResult);
    "update_user": (id: principal, input: UserDetailsInput) -> (UserResult);
    "update_user_orgs": (id: principal, org_ids: vec principal) -> (UserResult);
    "greet" : (text) -> (text) query;
    "generate_product_review": (product_id: principal) -> (opt Product);
    "find_resellers_by_name_or_id": (text) -> (vec Reseller) query;
    "verify_reseller": (reseller_id: principal, unique_code: text) -> (ResellerVerificationResult) query;
    "generate_reseller_unique_code": (reseller_id: principal) -> (UniqueCodeResult) query;
    "list_product_serial_number": (organization_id: opt principal, product_id: opt principal) -> (vec ProductSerialNumber) query;
    "create_product_serial_number": (product_id: principal, user_serial_no: opt text) -> (ProductSerialNumberResult);
    "update_product_serial_number": (product_id: principal, serial_no: principal, user_serial_no: opt text) -> (ProductSerialNumberResult);
    "print_product_serial_number": (product_id: principal, serial_no: principal) -> (ProductUniqueCodeResult);
    "verify_product": (product_id: principal, serial_no: principal, print_version: nat8, unique_code: text, metadata: vec Metadata) -> (ProductVerificationResult);
    "list_product_verifications": (organization_id: opt principal, product_id: opt principal, serial_number: opt principal) -> (vec ProductVerification) query;
    "list_product_verifications_by_user": (user_id: principal, organization_id: opt principal) -> (vec ProductVerification) query;
    
    "get_organization_by_id_v2": (id: principal) -> (ApiResponse_OrganizationResponse) query;
    "create_organization_v2": (request: CreateOrganizationRequest) -> (ApiResponse_OrganizationResponse);
    "update_organization_v2": (request: UpdateOrganizationRequest) -> (ApiResponse_OrganizationResponse);
    "list_organizations_v2": (request: FindOrganizationsRequest) -> (ApiResponse_OrganizationsListResponse);
    
    "verify_product_v2": (request: VerifyProductEnhancedRequest) -> (ApiResponse_ProductVerificationEnhancedResponse);
    "get_verification_rate_limit": (product_id: principal) -> (ApiResponse_RateLimitInfo) query;

    "generate_reseller_unique_code_v2": (request: GenerateResellerUniqueCodeRequest) -> (ApiResponse_ResellerUniqueCodeResponse);
    "verify_reseller_v2": (request: VerifyResellerRequestV2) -> (ApiResponse_ResellerVerificationResponse) query;

    "register_as_reseller_v2": (request: ResellerInput) -> (ApiResponse_UserResponse);

    // --- Configuration Endpoints (Admin Only)types
    "set_openai_api_key": (text) -> (ApiResponse_Unit);
    "get_openai_api_key": () -> (ApiResponse_Text) query;
    "set_scraper_url": (text) -> (ApiResponse_Unit);
    "get_scraper_url": () -> (ApiResponse_Text) query;

    // --- Product Service Endpoints --- Updated with specific ApiResponse types
    "generate_product_review_v2": (product_id: principal) -> (ApiResponse_ProductResponse);
};
</file>

</files>
